//go:build ignore
// +build ignore

// options_generator.go
// Code generator that produces functional-option builders for all Params structs in a Go package.
// Adds struct-base-specific suffix to avoid duplicate helper names.
// Usage: go run options_generator.go -input ./openapi.gen.go -output ./options_gen.go

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

var (
	inputPath   = flag.String("input", "", "Path to the Go source file or directory to scan for Params structs")
	outputPath  = flag.String("output", "", "Path to the generated Go file")
	packageName = flag.String("package", "", "Package name for the generated file (defaults to input package)")
)

// Struct holds information about a Params struct and its fields
type Struct struct {
	Name     string // full struct name e.g. GetCurrencyRatesParams
	BaseName string // struct name without "Params" suffix e.g. GetCurrencyRates
	Fields   []Field
}

type Field struct {
	Name     string // field name e.g. MarketCode
	RawType  string // raw type as in source e.g. *GetCurrencyRatesParamsLimitType
	BaseType string // underlying type without pointer e.g. GetCurrencyRatesParamsLimitType
	Pointer  bool   // true if the original type was a pointer
}

func main() {
	flag.Parse()
	if *inputPath == "" || *outputPath == "" {
		flag.Usage()
		os.Exit(1)
	}

	fset := token.NewFileSet()
	var pkgs map[string]*ast.Package
	var err error

	// Parse input path
	if fi, err := os.Stat(*inputPath); err != nil {
		log.Fatalf("invalid input path: %v", err)
	} else if fi.IsDir() {
		pkgs, err = parser.ParseDir(fset, *inputPath, nil, parser.AllErrors)
	} else {
		file, err := parser.ParseFile(fset, *inputPath, nil, parser.AllErrors)
		if err != nil {
			log.Fatalf("failed to parse file: %v", err)
		}
		pkgs = map[string]*ast.Package{file.Name.Name: &ast.Package{
			Name:  file.Name.Name,
			Files: map[string]*ast.File{*inputPath: file},
		}}
	}
	if err != nil {
		log.Fatalf("failed to parse: %v", err)
	}

	// Collect Params structs
	var structs []Struct
	var pkgName string
	for name, pkg := range pkgs {
		pkgName = name
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					continue
				}
				for _, spec := range gen.Specs {
					ts := spec.(*ast.TypeSpec)
					if !strings.HasSuffix(ts.Name.Name, "Params") {
						continue
					}
					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						continue
					}
					baseName := strings.TrimSuffix(ts.Name.Name, "Params")
					var fields []Field
					for _, f := range st.Fields.List {
						if len(f.Names) == 0 {
							continue
						}
						for _, nameIdent := range f.Names {
							var buf strings.Builder
							if err := printer.Fprint(&buf, fset, f.Type); err != nil {
								log.Fatalf("failed to print type: %v", err)
							}
							raw := buf.String()
							ptr := false
							base := raw
							if strings.HasPrefix(raw, "*") {
								ptr = true
								base = strings.TrimPrefix(raw, "*")
							}
							fields = append(fields, Field{
								Name:     nameIdent.Name,
								RawType:  raw,
								BaseType: base,
								Pointer:  ptr,
							})
						}
					}
					structs = append(structs, Struct{
						Name:     ts.Name.Name,
						BaseName: baseName,
						Fields:   fields,
					})
				}
			}
		}
		break
	}

	// Determine output package
	outPkg := *packageName
	if outPkg == "" {
		outPkg = pkgName
	}

	// Write file
	f, err := os.Create(*outputPath)
	if err != nil {
		log.Fatalf("cannot create output: %v", err)
	}
	defer f.Close()

	tmpl := template.Must(template.New("options").Parse(`// Code generated by options_generator.go; DO NOT EDIT.
package {{.Package}}

{{range .Structs}}{{ $s := . }}
// {{ $s.Name }}Option defines a functional option for {{ $s.Name }}.
type {{ $s.Name }}Option func(*{{ $s.Name }})

// {{ $s.Name }}FromOptions applies given options and returns a new {{ $s.Name }}.
func {{ $s.Name }}FromOptions(opts ...{{ $s.Name }}Option) *{{ $s.Name }} {
	p := &{{ $s.Name }}{}
	for _, opt := range opts {
		opt(p)
	}
	return p
}

{{range $s.Fields}}// With{{.Name}}For{{ $s.BaseName }} sets the {{.Name}} field on {{ $s.Name }}.
func With{{.Name}}For{{ $s.BaseName }}(v {{if .Pointer}}{{.BaseType}}{{else}}{{.RawType}}{{end}}) {{ $s.Name }}Option {
	return func(p *{{ $s.Name }}) {
		p.{{.Name}} = {{if .Pointer}}&v{{else}}v{{end}}
	}
}

{{end}}{{end}}`))

	tmplData := struct {
		Package string
		Structs []Struct
	}{outPkg, structs}

	if err := tmpl.Execute(f, tmplData); err != nil {
		log.Fatalf("template execution failed: %v", err)
	}

	fmt.Printf("Generated %d Params option builders in %s\n", len(structs), *outputPath)
}
