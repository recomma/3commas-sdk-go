// Package threecommas provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package threecommas

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	APIKEYScopes = "APIKEY.Scopes"
	SIGNEDScopes = "SIGNED.Scopes"
)

// Defines values for BotBaseOrderVolumeType.
const (
	BotBaseOrderVolumeTypeBaseCurrency  BotBaseOrderVolumeType = "base_currency"
	BotBaseOrderVolumeTypePercent       BotBaseOrderVolumeType = "percent"
	BotBaseOrderVolumeTypeQuoteCurrency BotBaseOrderVolumeType = "quote_currency"
)

// Defines values for BotLeverageType.
const (
	BotLeverageTypeCross    BotLeverageType = "cross"
	BotLeverageTypeIsolated BotLeverageType = "isolated"
)

// Defines values for BotMinProfitType.
const (
	BotMinProfitTypeBaseOrderVolume   BotMinProfitType = "base_order_volume"
	BotMinProfitTypeTotalBoughtVolume BotMinProfitType = "total_bought_volume"
)

// Defines values for BotProfitCurrency.
const (
	BotProfitCurrencyBaseCurrency  BotProfitCurrency = "base_currency"
	BotProfitCurrencyQuoteCurrency BotProfitCurrency = "quote_currency"
)

// Defines values for BotSafetyOrderVolumeType.
const (
	BotSafetyOrderVolumeTypeBaseCurrency  BotSafetyOrderVolumeType = "base_currency"
	BotSafetyOrderVolumeTypePercent       BotSafetyOrderVolumeType = "percent"
	BotSafetyOrderVolumeTypeQuoteCurrency BotSafetyOrderVolumeType = "quote_currency"
)

// Defines values for BotStartOrderType.
const (
	BotStartOrderTypeLimit  BotStartOrderType = "limit"
	BotStartOrderTypeMarket BotStartOrderType = "market"
)

// Defines values for BotStopLossType.
const (
	BotStopLossTypeStopLoss              BotStopLossType = "stop_loss"
	BotStopLossTypeStopLossAndDisableBot BotStopLossType = "stop_loss_and_disable_bot"
)

// Defines values for BotStrategy.
const (
	BotStrategyLong  BotStrategy = "long"
	BotStrategyShort BotStrategy = "short"
)

// Defines values for BotTakeProfitType.
const (
	BotTakeProfitTypeBase  BotTakeProfitType = "base"
	BotTakeProfitTypeTotal BotTakeProfitType = "total"
)

// Defines values for BotEntityBaseOrderVolumeType.
const (
	BotEntityBaseOrderVolumeTypeBaseCurrency  BotEntityBaseOrderVolumeType = "base_currency"
	BotEntityBaseOrderVolumeTypePercent       BotEntityBaseOrderVolumeType = "percent"
	BotEntityBaseOrderVolumeTypeQuoteCurrency BotEntityBaseOrderVolumeType = "quote_currency"
)

// Defines values for BotEntityLeverageType.
const (
	BotEntityLeverageTypeCross    BotEntityLeverageType = "cross"
	BotEntityLeverageTypeIsolated BotEntityLeverageType = "isolated"
)

// Defines values for BotEntityMinProfitType.
const (
	BotEntityMinProfitTypeBaseOrderVolume   BotEntityMinProfitType = "base_order_volume"
	BotEntityMinProfitTypeTotalBoughtVolume BotEntityMinProfitType = "total_bought_volume"
)

// Defines values for BotEntityProfitCurrency.
const (
	BotEntityProfitCurrencyBaseCurrency  BotEntityProfitCurrency = "base_currency"
	BotEntityProfitCurrencyQuoteCurrency BotEntityProfitCurrency = "quote_currency"
)

// Defines values for BotEntitySafetyOrderVolumeType.
const (
	BotEntitySafetyOrderVolumeTypeBaseCurrency  BotEntitySafetyOrderVolumeType = "base_currency"
	BotEntitySafetyOrderVolumeTypePercent       BotEntitySafetyOrderVolumeType = "percent"
	BotEntitySafetyOrderVolumeTypeQuoteCurrency BotEntitySafetyOrderVolumeType = "quote_currency"
)

// Defines values for BotEntityStartOrderType.
const (
	BotEntityStartOrderTypeLimit  BotEntityStartOrderType = "limit"
	BotEntityStartOrderTypeMarket BotEntityStartOrderType = "market"
)

// Defines values for BotEntityStopLossType.
const (
	BotEntityStopLossTypeStopLoss              BotEntityStopLossType = "stop_loss"
	BotEntityStopLossTypeStopLossAndDisableBot BotEntityStopLossType = "stop_loss_and_disable_bot"
)

// Defines values for BotEntityStrategy.
const (
	BotEntityStrategyLong  BotEntityStrategy = "long"
	BotEntityStrategyShort BotEntityStrategy = "short"
)

// Defines values for BotEntityTakeProfitType.
const (
	BotEntityTakeProfitTypeBase  BotEntityTakeProfitType = "base"
	BotEntityTakeProfitTypeTotal BotEntityTakeProfitType = "total"
)

// Defines values for DealUpdateRequestProfitCurrency.
const (
	BaseCurrency  DealUpdateRequestProfitCurrency = "base_currency"
	QuoteCurrency DealUpdateRequestProfitCurrency = "quote_currency"
)

// Defines values for DealUpdateRequestStopLossType.
const (
	StopLoss              DealUpdateRequestStopLossType = "stop_loss"
	StopLossAndDisableBot DealUpdateRequestStopLossType = "stop_loss_and_disable_bot"
)

// Defines values for DealUpdateRequestTakeProfitType.
const (
	Base  DealUpdateRequestTakeProfitType = "base"
	Total DealUpdateRequestTakeProfitType = "total"
)

// Defines values for MarketListItemAvailableConnectionFlows.
const (
	FastConnect MarketListItemAvailableConnectionFlows = "fast_connect"
	Form        MarketListItemAvailableConnectionFlows = "form"
)

// Defines values for GetCurrencyRatesParamsLimitType.
const (
	GetCurrencyRatesParamsLimitTypeBot        GetCurrencyRatesParamsLimitType = "bot"
	GetCurrencyRatesParamsLimitTypeSmartTrade GetCurrencyRatesParamsLimitType = "smart_trade"
)

// Defines values for ListBotsParamsStrategy.
const (
	ListBotsParamsStrategyLong  ListBotsParamsStrategy = "long"
	ListBotsParamsStrategyShort ListBotsParamsStrategy = "short"
)

// Defines values for ListBotsParamsOrderDirection.
const (
	ListBotsParamsOrderDirectionASC  ListBotsParamsOrderDirection = "ASC"
	ListBotsParamsOrderDirectionDESC ListBotsParamsOrderDirection = "DESC"
)

// Defines values for ListBotsParamsScope.
const (
	Disabled ListBotsParamsScope = "disabled"
	Enable   ListBotsParamsScope = "enable"
)

// Defines values for ListBotsParamsSortBy.
const (
	ListBotsParamsSortByCreatedAt ListBotsParamsSortBy = "created_at"
	ListBotsParamsSortByProfit    ListBotsParamsSortBy = "profit"
	ListBotsParamsSortByUpdatedAt ListBotsParamsSortBy = "updated_at"
)

// Defines values for ListStrategiesParamsType.
const (
	ListStrategiesParamsTypeLong  ListStrategiesParamsType = "long"
	ListStrategiesParamsTypeShort ListStrategiesParamsType = "short"
)

// Defines values for ListStrategiesParamsStrategy.
const (
	Composite ListStrategiesParamsStrategy = "composite"
	Simple    ListStrategiesParamsStrategy = "simple"
)

// Defines values for ListDealsParamsScope.
const (
	Active    ListDealsParamsScope = "active"
	Cancelled ListDealsParamsScope = "cancelled"
	Completed ListDealsParamsScope = "completed"
	Failed    ListDealsParamsScope = "failed"
	Finished  ListDealsParamsScope = "finished"
)

// Defines values for ListDealsParamsOrder.
const (
	ListDealsParamsOrderClosedAt         ListDealsParamsOrder = "closed_at"
	ListDealsParamsOrderCreatedAt        ListDealsParamsOrder = "created_at"
	ListDealsParamsOrderProfit           ListDealsParamsOrder = "profit"
	ListDealsParamsOrderProfitPercentage ListDealsParamsOrder = "profit_percentage"
	ListDealsParamsOrderUpdatedAt        ListDealsParamsOrder = "updated_at"
)

// Defines values for ListDealsParamsOrderDirection.
const (
	ListDealsParamsOrderDirectionASC  ListDealsParamsOrderDirection = "ASC"
	ListDealsParamsOrderDirectionDESC ListDealsParamsOrderDirection = "DESC"
)

// Bot defines model for Bot.
type Bot struct {
	// AccountId ID of the exchange account entity where you want to create the DCA Bot.
	AccountId int `json:"account_id"`

	// AccountName Exchange-account name shown to the user.
	AccountName *string `json:"account_name,omitempty"`

	// ActiveDeals List of active deals managed by this DCA Bot.
	ActiveDeals *[]Deal `json:"active_deals,omitempty"`

	// ActiveDealsBtcProfit Unrealised P/L of active deals (BTC).
	ActiveDealsBtcProfit *string `json:"active_deals_btc_profit,omitempty"`

	// ActiveDealsCount Number of active deals.
	ActiveDealsCount *int `json:"active_deals_count,omitempty"`

	// ActiveDealsUsdProfit Unrealised P/L of active deals (USD).
	ActiveDealsUsdProfit *string `json:"active_deals_usd_profit,omitempty"`

	// ActiveSafetyOrdersCount Number of safety orders the bot may place concurrently.
	ActiveSafetyOrdersCount *int `json:"active_safety_orders_count,omitempty"`

	// AllowedDealsOnSamePair Max concurrent deals on the same pair (MultiBot only).
	AllowedDealsOnSamePair *int `json:"allowed_deals_on_same_pair,omitempty"`

	// BaseOrderVolume The volume of the base order for this DCA Bot.
	BaseOrderVolume *string `json:"base_order_volume,omitempty"`

	// BaseOrderVolumeType The volume type of the base order.
	BaseOrderVolumeType *BotBaseOrderVolumeType `json:"base_order_volume_type,omitempty"`

	// BtcFundsLockedInActiveDeals BTC currently locked in active deals.
	BtcFundsLockedInActiveDeals *string `json:"btc_funds_locked_in_active_deals,omitempty"`

	// CloseDealsTimeout Auto-close deals after this many seconds.
	CloseDealsTimeout *string `json:"close_deals_timeout,omitempty"`

	// CloseStrategyList Array of strategies used for closing deals.
	CloseStrategyList *[]StrategyConfig `json:"close_strategy_list,omitempty"`

	// Cooldown Time after closing a deal before a new one can start (seconds).
	Cooldown *string `json:"cooldown,omitempty"`

	// CreatedAt ISO-8601 timestamp when the bot was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DealStartDelaySeconds Delay before a new deal starts (seconds).
	DealStartDelaySeconds *int `json:"deal_start_delay_seconds,omitempty"`

	// Deletable Indicates whether this bot can be deleted.
	Deletable *bool `json:"deletable?,omitempty"`

	// DisableAfterDealsCount Number of deals after which the bot disables itself.
	DisableAfterDealsCount *int `json:"disable_after_deals_count,omitempty"`

	// FinishedDealsCount Total number of finished deals.
	FinishedDealsCount *string `json:"finished_deals_count,omitempty"`

	// FinishedDealsProfitUsd Cumulative USD profit from finished deals.
	FinishedDealsProfitUsd *string `json:"finished_deals_profit_usd,omitempty"`

	// FundsLockedInActiveDeals USD currently locked in active deals.
	FundsLockedInActiveDeals *string `json:"funds_locked_in_active_deals,omitempty"`

	// Id Unique 3Commas ID for this DCA Bot.
	Id int `json:"id"`

	// IsEnabled Whether the bot is currently enabled.
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// LeverageCustomValue Leverage value (exchange- and pair-dependent).
	LeverageCustomValue *float32 `json:"leverage_custom_value,omitempty"`

	// LeverageType Sets leverage settings for a futures account.
	LeverageType *BotLeverageType `json:"leverage_type,omitempty"`

	// MartingaleStepCoefficient Multiplier for increasing safety order step (Martingale).
	MartingaleStepCoefficient *string `json:"martingale_step_coefficient,omitempty"`

	// MartingaleVolumeCoefficient Multiplier for increasing safety order volume (Martingale).
	MartingaleVolumeCoefficient *string `json:"martingale_volume_coefficient,omitempty"`

	// MaxActiveDeals The maximum number of active deals available for this DCA Bot.
	MaxActiveDeals *int `json:"max_active_deals,omitempty"`

	// MaxPrice Maximum price to open a new deal.
	MaxPrice *float32 `json:"max_price,omitempty"`

	// MaxPricePercentage Maximum entry price percentage (−95 to 1000).
	MaxPricePercentage *float32 `json:"max_price_percentage,omitempty"`

	// MaxSafetyOrders Maximum total number of safety orders per deal.
	MaxSafetyOrders *int `json:"max_safety_orders,omitempty"`

	// MinPrice Minimum price to open a new deal.
	MinPrice *float32 `json:"min_price,omitempty"`

	// MinPricePercentage Minimum entry price percentage (−95 to 1000).
	MinPricePercentage *float32 `json:"min_price_percentage,omitempty"`

	// MinProfitPercentage Minimum profit percentage required to complete a deal.
	MinProfitPercentage *string `json:"min_profit_percentage,omitempty"`

	// MinProfitType Basis for minimum profit calculation.
	MinProfitType *BotMinProfitType `json:"min_profit_type,omitempty"`

	// MinVolumeBtc24h Minimum 24h BTC volume required to open a deal.
	MinVolumeBtc24h *string `json:"min_volume_btc_24h,omitempty"`

	// Name User-defined name of the DCA Bot. If not specified, the system will generate a default name automatically.
	Name *string `json:"name,omitempty"`

	// Pairs Trading pair(s) in 3Commas format.
	Pairs Pairs `json:"pairs"`

	// ProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
	ProfitCurrency *BotProfitCurrency `json:"profit_currency,omitempty"`

	// ReinvestedVolumeUsd USD volume reinvested from profit.
	ReinvestedVolumeUsd nullable.Nullable[float32] `json:"reinvested_volume_usd,omitempty"`

	// ReinvestingPercentage Percentage of realized profit to reinvest in each new deal.
	ReinvestingPercentage *string `json:"reinvesting_percentage,omitempty"`

	// RiskReductionPercentage Percentage of losses to reduce base and safety orders proportionally.
	RiskReductionPercentage *string `json:"risk_reduction_percentage,omitempty"`

	// SafetyOrderStepPercentage Price deviation (%) to open each safety order.
	SafetyOrderStepPercentage *string `json:"safety_order_step_percentage,omitempty"`

	// SafetyOrderVolume Volume of each safety order.
	SafetyOrderVolume *string `json:"safety_order_volume,omitempty"`

	// SafetyOrderVolumeType Volume type for safety orders.
	SafetyOrderVolumeType *BotSafetyOrderVolumeType `json:"safety_order_volume_type,omitempty"`

	// SafetyStrategyList Array of strategies for executing safety orders.
	SafetyStrategyList *[]StrategyConfig `json:"safety_strategy_list,omitempty"`

	// SlToBreakevenData Configuration for breakeven trigger levels (0 = entry price, 1 = first TP step, etc.).
	SlToBreakevenData *map[string]interface{} `json:"sl_to_breakeven_data,omitempty"`

	// SlToBreakevenEnabled Enables the Move-to-Breakeven feature.
	SlToBreakevenEnabled *bool `json:"sl_to_breakeven_enabled,omitempty"`

	// StartOrderType The start order type for this DCA Bot.
	StartOrderType *BotStartOrderType `json:"start_order_type,omitempty"`

	// StopLossPercentage Percentage drop to trigger Stop Loss.
	StopLossPercentage *string `json:"stop_loss_percentage,omitempty"`

	// StopLossTimeoutEnabled Enables Stop Loss timeout.
	StopLossTimeoutEnabled *bool `json:"stop_loss_timeout_enabled,omitempty"`

	// StopLossTimeoutInSeconds Timeout duration in seconds for Stop Loss.
	StopLossTimeoutInSeconds *int `json:"stop_loss_timeout_in_seconds,omitempty"`

	// StopLossType Action after Stop Loss closes a deal.
	StopLossType *BotStopLossType `json:"stop_loss_type,omitempty"`

	// Strategy The type of trading strategy used by this DCA Bot.
	Strategy *BotStrategy `json:"strategy,omitempty"`

	// StrategyList Array of strategies specifically for opening deals.
	StrategyList *[]StrategyConfig `json:"strategy_list,omitempty"`

	// TakeProfit Percentage value for the bot’s Take Profit. Set to 0 if using steps.
	TakeProfit *string `json:"take_profit,omitempty"`

	// TakeProfitSteps Take Profit steps (up to 4), each with:
	// - amount_percentage
	// - profit_percentage
	TakeProfitSteps *[]TakeProfitStep `json:"take_profit_steps,omitempty"`

	// TakeProfitType Basis for Take Profit calculation.
	TakeProfitType *BotTakeProfitType `json:"take_profit_type,omitempty"`

	// TrailingDeviation Percentage value of the trailing deviation.
	TrailingDeviation *string `json:"trailing_deviation,omitempty"`

	// TrailingEnabled Enables trailing for Take Profit.
	TrailingEnabled *bool `json:"trailing_enabled,omitempty"`

	// TslEnabled Enables trailing for Stop Loss.
	TslEnabled *bool `json:"tsl_enabled,omitempty"`

	// UpdatedAt ISO-8601 timestamp of last update.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BotBaseOrderVolumeType The volume type of the base order.
type BotBaseOrderVolumeType string

// BotLeverageType Sets leverage settings for a futures account.
type BotLeverageType string

// BotMinProfitType Basis for minimum profit calculation.
type BotMinProfitType string

// BotProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
type BotProfitCurrency string

// BotSafetyOrderVolumeType Volume type for safety orders.
type BotSafetyOrderVolumeType string

// BotStartOrderType The start order type for this DCA Bot.
type BotStartOrderType string

// BotStopLossType Action after Stop Loss closes a deal.
type BotStopLossType string

// BotStrategy The type of trading strategy used by this DCA Bot.
type BotStrategy string

// BotTakeProfitType Basis for Take Profit calculation.
type BotTakeProfitType string

// BotEntity defines model for BotEntity.
type BotEntity struct {
	// AccountId ID of the exchange account entity where you want to create the DCA Bot.
	AccountId int `json:"account_id"`

	// ActiveSafetyOrdersCount Number of safety orders the bot may place concurrently.
	ActiveSafetyOrdersCount *int `json:"active_safety_orders_count,omitempty"`

	// AllowedDealsOnSamePair Max concurrent deals on the same pair (MultiBot only).
	AllowedDealsOnSamePair *int `json:"allowed_deals_on_same_pair,omitempty"`

	// BaseOrderVolume The volume of the base order for this DCA Bot.
	BaseOrderVolume *string `json:"base_order_volume,omitempty"`

	// BaseOrderVolumeType The volume type of the base order.
	BaseOrderVolumeType *BotEntityBaseOrderVolumeType `json:"base_order_volume_type,omitempty"`

	// CloseDealsTimeout Auto-close deals after this many seconds.
	CloseDealsTimeout *string `json:"close_deals_timeout,omitempty"`

	// CloseStrategyList Array of strategies used for closing deals.
	CloseStrategyList *[]StrategyConfig `json:"close_strategy_list,omitempty"`

	// Cooldown Time after closing a deal before a new one can start (seconds).
	Cooldown *string `json:"cooldown,omitempty"`

	// DealStartDelaySeconds Delay before a new deal starts (seconds).
	DealStartDelaySeconds *int `json:"deal_start_delay_seconds,omitempty"`

	// DisableAfterDealsCount Number of deals after which the bot disables itself.
	DisableAfterDealsCount *int `json:"disable_after_deals_count,omitempty"`

	// LeverageCustomValue Leverage value (exchange- and pair-dependent).
	LeverageCustomValue *float32 `json:"leverage_custom_value,omitempty"`

	// LeverageType Sets leverage settings for a futures account.
	LeverageType *BotEntityLeverageType `json:"leverage_type,omitempty"`

	// MartingaleStepCoefficient Multiplier for increasing safety order step (Martingale).
	MartingaleStepCoefficient *string `json:"martingale_step_coefficient,omitempty"`

	// MartingaleVolumeCoefficient Multiplier for increasing safety order volume (Martingale).
	MartingaleVolumeCoefficient *string `json:"martingale_volume_coefficient,omitempty"`

	// MaxActiveDeals The maximum number of active deals available for this DCA Bot.
	MaxActiveDeals *int `json:"max_active_deals,omitempty"`

	// MaxPrice Maximum price to open a new deal.
	MaxPrice *float32 `json:"max_price,omitempty"`

	// MaxPricePercentage Maximum entry price percentage (−95 to 1000).
	MaxPricePercentage *float32 `json:"max_price_percentage,omitempty"`

	// MaxSafetyOrders Maximum total number of safety orders per deal.
	MaxSafetyOrders *int `json:"max_safety_orders,omitempty"`

	// MinPrice Minimum price to open a new deal.
	MinPrice *float32 `json:"min_price,omitempty"`

	// MinPricePercentage Minimum entry price percentage (−95 to 1000).
	MinPricePercentage *float32 `json:"min_price_percentage,omitempty"`

	// MinProfitPercentage Minimum profit percentage required to complete a deal.
	MinProfitPercentage *string `json:"min_profit_percentage,omitempty"`

	// MinProfitType Basis for minimum profit calculation.
	MinProfitType *BotEntityMinProfitType `json:"min_profit_type,omitempty"`

	// MinVolumeBtc24h Minimum 24h BTC volume required to open a deal.
	MinVolumeBtc24h *string `json:"min_volume_btc_24h,omitempty"`

	// Name User-defined name of the DCA Bot. If not specified, the system will generate a default name automatically.
	Name *string `json:"name,omitempty"`

	// Pairs Trading pair(s) in 3Commas format.
	Pairs Pairs `json:"pairs"`

	// ProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
	ProfitCurrency *BotEntityProfitCurrency `json:"profit_currency,omitempty"`

	// ReinvestingPercentage Percentage of realized profit to reinvest in each new deal.
	ReinvestingPercentage *string `json:"reinvesting_percentage,omitempty"`

	// RiskReductionPercentage Percentage of losses to reduce base and safety orders proportionally.
	RiskReductionPercentage *string `json:"risk_reduction_percentage,omitempty"`

	// SafetyOrderStepPercentage Price deviation (%) to open each safety order.
	SafetyOrderStepPercentage *string `json:"safety_order_step_percentage,omitempty"`

	// SafetyOrderVolume Volume of each safety order.
	SafetyOrderVolume *string `json:"safety_order_volume,omitempty"`

	// SafetyOrderVolumeType Volume type for safety orders.
	SafetyOrderVolumeType *BotEntitySafetyOrderVolumeType `json:"safety_order_volume_type,omitempty"`

	// SafetyStrategyList Array of strategies for executing safety orders.
	SafetyStrategyList *[]StrategyConfig `json:"safety_strategy_list,omitempty"`

	// SlToBreakevenData Configuration for breakeven trigger levels (0 = entry price, 1 = first TP step, etc.).
	SlToBreakevenData *map[string]interface{} `json:"sl_to_breakeven_data,omitempty"`

	// SlToBreakevenEnabled Enables the Move-to-Breakeven feature.
	SlToBreakevenEnabled *bool `json:"sl_to_breakeven_enabled,omitempty"`

	// StartOrderType The start order type for this DCA Bot.
	StartOrderType *BotEntityStartOrderType `json:"start_order_type,omitempty"`

	// StopLossPercentage Percentage drop to trigger Stop Loss.
	StopLossPercentage *string `json:"stop_loss_percentage,omitempty"`

	// StopLossTimeoutEnabled Enables Stop Loss timeout.
	StopLossTimeoutEnabled *bool `json:"stop_loss_timeout_enabled,omitempty"`

	// StopLossTimeoutInSeconds Timeout duration in seconds for Stop Loss.
	StopLossTimeoutInSeconds *int `json:"stop_loss_timeout_in_seconds,omitempty"`

	// StopLossType Action after Stop Loss closes a deal.
	StopLossType *BotEntityStopLossType `json:"stop_loss_type,omitempty"`

	// Strategy The type of trading strategy used by this DCA Bot.
	Strategy *BotEntityStrategy `json:"strategy,omitempty"`

	// StrategyList Array of strategies specifically for opening deals.
	StrategyList *[]StrategyConfig `json:"strategy_list,omitempty"`

	// TakeProfit Percentage value for the bot’s Take Profit. Set to 0 if using steps.
	TakeProfit *string `json:"take_profit,omitempty"`

	// TakeProfitSteps Take Profit steps (up to 4), each with:
	// - amount_percentage
	// - profit_percentage
	TakeProfitSteps *[]TakeProfitStep `json:"take_profit_steps,omitempty"`

	// TakeProfitType Basis for Take Profit calculation.
	TakeProfitType *BotEntityTakeProfitType `json:"take_profit_type,omitempty"`

	// TrailingDeviation Percentage value of the trailing deviation.
	TrailingDeviation *string `json:"trailing_deviation,omitempty"`

	// TrailingEnabled Enables trailing for Take Profit.
	TrailingEnabled *bool `json:"trailing_enabled,omitempty"`

	// TslEnabled Enables trailing for Stop Loss.
	TslEnabled *bool `json:"tsl_enabled,omitempty"`
}

// BotEntityBaseOrderVolumeType The volume type of the base order.
type BotEntityBaseOrderVolumeType string

// BotEntityLeverageType Sets leverage settings for a futures account.
type BotEntityLeverageType string

// BotEntityMinProfitType Basis for minimum profit calculation.
type BotEntityMinProfitType string

// BotEntityProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
type BotEntityProfitCurrency string

// BotEntitySafetyOrderVolumeType Volume type for safety orders.
type BotEntitySafetyOrderVolumeType string

// BotEntityStartOrderType The start order type for this DCA Bot.
type BotEntityStartOrderType string

// BotEntityStopLossType Action after Stop Loss closes a deal.
type BotEntityStopLossType string

// BotEntityStrategy The type of trading strategy used by this DCA Bot.
type BotEntityStrategy string

// BotEntityTakeProfitType Basis for Take Profit calculation.
type BotEntityTakeProfitType string

// BotsStats defines model for BotsStats.
type BotsStats struct {
	// OverallStats Cumulative profit or loss by currency for all trading activity.
	OverallStats *map[string]string `json:"overall_stats,omitempty"`

	// ProfitsInUsd Detailed profit and loss data in USD.
	ProfitsInUsd *struct {
		// ActiveDealsUsdProfit USD profit or loss from active (unclosed) deals.
		ActiveDealsUsdProfit float32 `json:"active_deals_usd_profit"`

		// FundsLockedInActiveDeals Funds locked in active deals, in USD.
		FundsLockedInActiveDeals float32 `json:"funds_locked_in_active_deals"`

		// OverallUsdProfit Cumulative USD profit or loss from all trading activity.
		OverallUsdProfit float32 `json:"overall_usd_profit"`

		// TodayUsdProfit USD profit or loss accumulated for the current day.
		TodayUsdProfit float32 `json:"today_usd_profit"`
	} `json:"profits_in_usd,omitempty"`

	// TodayStats Today's profit or loss by currency.
	TodayStats *map[string]string `json:"today_stats,omitempty"`
}

// BotsStatsByDate defines model for BotsStatsByDate.
type BotsStatsByDate struct {
	// BtcProfit BTC profit from deals for the specified day.
	BtcProfit string `json:"btc_profit"`

	// Stats Profit by currency for the specified date.
	Stats map[string]string `json:"stats"`

	// UsdProfit USD profit from deals for the specified day.
	UsdProfit string `json:"usd_profit"`
}

// CopyBotRequest defines model for CopyBotRequest.
type CopyBotRequest struct {
	// Amount Amount allocated for bot usage.
	Amount float32 `json:"amount"`

	// Name The name for the new DCA Bot specified by the user.
	Name string `json:"name"`

	// Secret A unique code used for copying this bot, retrieved from the url_secret parameter.
	Secret string `json:"secret"`
}

// CopyBotResponse defines model for CopyBotResponse.
type CopyBotResponse struct {
	// BotId Unique 3Commas ID for the newly created DCA Bot.
	BotId *float32 `json:"bot_id,omitempty"`

	// BotRequiredAmount The minimum amount of funds required to launch this bot.
	BotRequiredAmount *float32 `json:"bot_required_amount,omitempty"`
}

// CreateBotRequest defines model for CreateBotRequest.
type CreateBotRequest = BotEntity

// CurrencyRates defines model for CurrencyRates.
type CurrencyRates struct {
	// Ask Ask price.
	Ask string `json:"ask"`

	// AskMultiplierDown A multiplier applied to decrease the ask price.
	AskMultiplierDown string `json:"askMultiplierDown"`

	// AskMultiplierUp A multiplier applied to increase the ask price.
	AskMultiplierUp string `json:"askMultiplierUp"`

	// Bid Bid price.
	Bid string `json:"bid"`

	// BidMultiplierDown A multiplier applied to decrease the bid price.
	BidMultiplierDown string `json:"bidMultiplierDown"`

	// BidMultiplierUp A multiplier applied to increase the bid price.
	BidMultiplierUp string `json:"bidMultiplierUp"`

	// ContractStrategyName The strategy by which the contract price is calculated.
	ContractStrategyName string `json:"contract_strategy_name"`

	// InstrumentKind The type of exchange instrument.
	InstrumentKind string `json:"instrumentKind"`

	// Last Last price.
	Last string `json:"last"`

	// LotStep Order of changing the size in Base currency.
	LotStep string `json:"lotStep"`

	// MaxLotSize Maximum order size in Base.
	MaxLotSize string `json:"maxLotSize"`

	// MaxMarketBuyAmount Maximum order size in Base currency for buy.
	MaxMarketBuyAmount string `json:"maxMarketBuyAmount"`

	// MaxMarketSellAmount Maximum order size in Base currency for sell.
	MaxMarketSellAmount string `json:"maxMarketSellAmount"`

	// MaxPrice Maximum price order.
	MaxPrice string `json:"maxPrice"`

	// MaxTotal Maximum order size in Quote.
	MaxTotal string `json:"maxTotal"`

	// MinLotSize The minimum lot size for order in Base currency.
	MinLotSize string `json:"minLotSize"`

	// MinMarketTotal Minimum order size in Quote for market order.
	MinMarketTotal string `json:"minMarketTotal"`

	// MinPrice Minimum price order.
	MinPrice string `json:"minPrice"`

	// MinTotal Minimum order size in Quote.
	MinTotal string `json:"minTotal"`

	// OrderbookAsk Ask price of ticker.
	OrderbookAsk string `json:"orderbook_ask"`

	// OrderbookBid Bid price of ticker.
	OrderbookBid string `json:"orderbook_bid"`

	// OrderbookLast Last price of ticker.
	OrderbookLast string `json:"orderbook_last"`

	// OrderbookPriceCurrency Currency price of ticker.
	OrderbookPriceCurrency string `json:"orderbook_price_currency"`

	// PriceStep The minimum step for changing the price.
	PriceStep string `json:"priceStep"`

	// StrategyName The name of trading strategy.
	StrategyName string `json:"strategy_name"`
}

// CurrencyRatesWithLeverageData defines model for CurrencyRatesWithLeverageData.
type CurrencyRatesWithLeverageData struct {
	// Ask Ask price.
	Ask string `json:"ask"`

	// AskMultiplierDown A multiplier applied to decrease the ask price.
	AskMultiplierDown string `json:"askMultiplierDown"`

	// AskMultiplierUp A multiplier applied to increase the ask price.
	AskMultiplierUp string `json:"askMultiplierUp"`

	// Bid Bid price.
	Bid string `json:"bid"`

	// BidMultiplierDown A multiplier applied to decrease the bid price.
	BidMultiplierDown string `json:"bidMultiplierDown"`

	// BidMultiplierUp A multiplier applied to increase the bid price.
	BidMultiplierUp string `json:"bidMultiplierUp"`

	// ContractStrategyName The strategy by which the contract price is calculated.
	ContractStrategyName string `json:"contract_strategy_name"`

	// InstrumentKind The type of exchange instrument.
	InstrumentKind string `json:"instrumentKind"`

	// Last Last price.
	Last string `json:"last"`

	// LeverageData Represents leverage data for this pair.
	LeverageData []LeverageData `json:"leverage_data"`

	// LotStep Order of changing the size in Base currency.
	LotStep string `json:"lotStep"`

	// MaxLotSize Maximum order size in Base.
	MaxLotSize string `json:"maxLotSize"`

	// MaxMarketBuyAmount Maximum order size in Base currency for buy.
	MaxMarketBuyAmount string `json:"maxMarketBuyAmount"`

	// MaxMarketSellAmount Maximum order size in Base currency for sell.
	MaxMarketSellAmount string `json:"maxMarketSellAmount"`

	// MaxPrice Maximum price order.
	MaxPrice string `json:"maxPrice"`

	// MaxTotal Maximum order size in Quote.
	MaxTotal string `json:"maxTotal"`

	// MinLotSize The minimum lot size for order in Base currency.
	MinLotSize string `json:"minLotSize"`

	// MinMarketBuyAmount Minimum order size in Base currency for buy.
	MinMarketBuyAmount *string `json:"minMarketBuyAmount,omitempty"`

	// MinMarketSellAmount Minimum order size in Base currency for sell.
	MinMarketSellAmount *string `json:"minMarketSellAmount,omitempty"`

	// MinMarketTotal Minimum order size in Quote for market order.
	MinMarketTotal string `json:"minMarketTotal"`

	// MinPrice Minimum price order.
	MinPrice string `json:"minPrice"`

	// MinTotal Minimum order size in Quote.
	MinTotal string `json:"minTotal"`

	// OrderbookAsk Ask price of ticker.
	OrderbookAsk string `json:"orderbook_ask"`

	// OrderbookBid Bid price of ticker.
	OrderbookBid string `json:"orderbook_bid"`

	// OrderbookLast Last price of ticker.
	OrderbookLast string `json:"orderbook_last"`

	// OrderbookPriceCurrency Currency price of ticker.
	OrderbookPriceCurrency string `json:"orderbook_price_currency"`

	// PriceStep The minimum step for changing the price.
	PriceStep string `json:"priceStep"`

	// StrategyName The name of trading strategy.
	StrategyName string `json:"strategy_name"`
}

// Deal A single DCA‐bot deal, with all its execution and P/L details.
type Deal struct {
	// AccountId Unique 3Commas ID for the exchange account used.
	AccountId *int `json:"account_id,omitempty"`

	// AccountName The name of the exchange account, as set by the user.
	AccountName *string `json:"account_name,omitempty"`

	// ActiveManualSafetyOrders Number of active manually‐triggered safety orders.
	ActiveManualSafetyOrders *int `json:"active_manual_safety_orders,omitempty"`

	// ActiveSafetyOrdersCount Number of safety orders the bot may place concurrently.
	ActiveSafetyOrdersCount *int `json:"active_safety_orders_count,omitempty"`

	// ActualProfit Realized P/L after execution.
	ActualProfit nullable.Nullable[string] `json:"actual_profit,omitempty"`

	// ActualProfitPercentage Realized profit percentage.
	ActualProfitPercentage *string `json:"actual_profit_percentage,omitempty"`

	// ActualUsdProfit Realized P/L in USD.
	ActualUsdProfit nullable.Nullable[string] `json:"actual_usd_profit,omitempty"`

	// AddFundable Whether adding funds is allowed.
	AddFundable *bool `json:"add_fundable,omitempty"`

	// BaseOrderAveragePrice Average price of the base order.
	BaseOrderAveragePrice *string `json:"base_order_average_price,omitempty"`

	// BaseOrderVolume Volume of the base order.
	BaseOrderVolume *string `json:"base_order_volume,omitempty"`

	// BaseOrderVolumeType Volume type of the base order.
	BaseOrderVolumeType *string `json:"base_order_volume_type,omitempty"`

	// BotEvents Log of bot events for this deal.
	BotEvents *[]struct {
		// CreatedAt When the event occurred.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Message Event description.
		Message *string `json:"message,omitempty"`
	} `json:"bot_events,omitempty"`

	// BotId Unique 3Commas ID for the DCA Bot that opened this deal.
	BotId *int `json:"bot_id,omitempty"`

	// BotName DCA Bot name specified by the user.
	BotName *string `json:"bot_name,omitempty"`

	// BoughtAmount Amount of asset bought.
	BoughtAmount *string `json:"bought_amount,omitempty"`

	// BoughtAveragePrice Average price of the buy.
	BoughtAveragePrice *string `json:"bought_average_price,omitempty"`

	// BoughtVolume Quote‐currency volume spent.
	BoughtVolume *string `json:"bought_volume,omitempty"`

	// Cancellable Whether this deal can still be canceled.
	Cancellable *bool `json:"cancellable?,omitempty"`

	// CloseStrategyList Custom close strategies applied.
	CloseStrategyList *[]map[string]interface{} `json:"close_strategy_list,omitempty"`

	// ClosedAt When the Deal was closed, or `null` if still open.
	ClosedAt nullable.Nullable[time.Time] `json:"closed_at,omitempty"`

	// CompletedManualSafetyOrdersCount Number of manually‐triggered safety orders that have completed.
	CompletedManualSafetyOrdersCount *int `json:"completed_manual_safety_orders_count,omitempty"`

	// CompletedSafetyOrdersCount How many safety orders have already been filled.
	CompletedSafetyOrdersCount *int `json:"completed_safety_orders_count,omitempty"`

	// CreatedAt When the Deal was created (ISO 8601).
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrentActiveSafetyOrders Currently active safety orders.
	CurrentActiveSafetyOrders *int `json:"current_active_safety_orders,omitempty"`

	// CurrentActiveSafetyOrdersCount Currently active safety orders (including manual).
	CurrentActiveSafetyOrdersCount *int `json:"current_active_safety_orders_count,omitempty"`

	// CurrentPrice Latest market price.
	CurrentPrice *string `json:"current_price,omitempty"`

	// DealHasError Indicates whether this Deal has encountered any errors.
	DealHasError *bool `json:"deal_has_error,omitempty"`

	// ErrorMessage Error message if the deal failed.
	ErrorMessage nullable.Nullable[string] `json:"error_message,omitempty"`

	// FinalProfit Net P/L (in profit currency).
	FinalProfit *string `json:"final_profit,omitempty"`

	// FinalProfitPercentage Net P/L percentage.
	FinalProfitPercentage *string `json:"final_profit_percentage,omitempty"`

	// Finished Whether this Deal has finished (`true`) or is still in progress (`false`).
	Finished *bool `json:"finished?,omitempty"`

	// FromCurrency Quote currency code.
	FromCurrency   *string `json:"from_currency,omitempty"`
	FromCurrencyId *int    `json:"from_currency_id,omitempty"`

	// Id Unique 3Commas ID for this Deal entity.
	Id *int `json:"id,omitempty"`

	// LeverageCustomValue User‐set leverage value.
	LeverageCustomValue nullable.Nullable[string] `json:"leverage_custom_value,omitempty"`

	// LeverageType Leverage mode (`cross`, `isolated`, or `not_specified`).
	LeverageType *string `json:"leverage_type,omitempty"`

	// LocalizedStatus Human‐readable status.
	LocalizedStatus *string `json:"localized_status,omitempty"`

	// MarketType Exchange market type (`spot` or `futures`).
	MarketType *string `json:"market_type,omitempty"`

	// MartingaleStepCoefficient Martingale step multiplier.
	MartingaleStepCoefficient *string `json:"martingale_step_coefficient,omitempty"`

	// MartingaleVolumeCoefficient Martingale volume multiplier.
	MartingaleVolumeCoefficient *string `json:"martingale_volume_coefficient,omitempty"`

	// MaxSafetyOrders Maximum number of safety orders allowed for this deal.
	MaxSafetyOrders *int `json:"max_safety_orders,omitempty"`

	// MinProfitPercentage Minimum profit % for TP close strategy.
	MinProfitPercentage *string `json:"min_profit_percentage,omitempty"`

	// MinProfitType Basis for minimum profit calculation.
	MinProfitType nullable.Nullable[string] `json:"min_profit_type,omitempty"`

	// Note Optional user note.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// OrderbookPriceCurrency Currency used for orderbook quotes.
	OrderbookPriceCurrency *string `json:"orderbook_price_currency,omitempty"`

	// Pair Trading pair in 3Commas format.
	Pair *string `json:"pair,omitempty"`

	// PanicSellable Whether this deal can still be closed at market price.
	PanicSellable *bool `json:"panic_sellable?,omitempty"`

	// ProfitCurrency Currency for profit calculation.
	ProfitCurrency *string `json:"profit_currency,omitempty"`

	// SafetyOrderStepPercentage Price deviation (%) between safety orders.
	SafetyOrderStepPercentage *string `json:"safety_order_step_percentage,omitempty"`

	// SafetyOrderVolume Size of each safety order.
	SafetyOrderVolume *string `json:"safety_order_volume,omitempty"`

	// SafetyOrderVolumeType Volume type for safety orders (e.g. `quote_currency`, `base_currency`, `percent`).
	SafetyOrderVolumeType *string `json:"safety_order_volume_type,omitempty"`

	// SafetyStrategyList Custom strategies for safety orders.
	SafetyStrategyList *[]map[string]interface{} `json:"safety_strategy_list,omitempty"`

	// SlToBreakevenData Breakeven config (e.g. `{ "upper_breakeven_limit": 1 }`).
	SlToBreakevenData nullable.Nullable[map[string]interface{}] `json:"sl_to_breakeven_data,omitempty"`

	// SlToBreakevenEnabled Move-to-Breakeven feature enabled.
	SlToBreakevenEnabled *bool `json:"sl_to_breakeven_enabled,omitempty"`

	// SmartTradeConvertable Whether this deal can be converted to a SmartTrade.
	SmartTradeConvertable *bool `json:"smart_trade_convertable,omitempty"`

	// SoldAmount Amount of asset sold.
	SoldAmount *string `json:"sold_amount,omitempty"`

	// SoldAveragePrice Average sell price.
	SoldAveragePrice *string `json:"sold_average_price,omitempty"`

	// SoldVolume Quote‐currency volume received from sells.
	SoldVolume *string `json:"sold_volume,omitempty"`

	// Status Deal status (e.g. `bought`, `completed`, `failed`).
	Status *string `json:"status,omitempty"`

	// StopLossPercentage Stop-Loss trigger percentage.
	StopLossPercentage *string `json:"stop_loss_percentage,omitempty"`

	// StopLossPrice SL trigger price.
	StopLossPrice *string `json:"stop_loss_price,omitempty"`

	// StopLossTimeoutEnabled Whether Stop-Loss timeout is enabled.
	StopLossTimeoutEnabled *bool `json:"stop_loss_timeout_enabled,omitempty"`

	// StopLossTimeoutInSeconds Duration (s) of Stop-Loss timeout.
	StopLossTimeoutInSeconds *int `json:"stop_loss_timeout_in_seconds,omitempty"`

	// StopLossType What action occurs on Stop-Loss.
	StopLossType *string `json:"stop_loss_type,omitempty"`

	// TakeProfit Take Profit percentage, or `null` if using steps.
	TakeProfit nullable.Nullable[string] `json:"take_profit,omitempty"`

	// TakeProfitPrice TP trigger price (single‐condition bots).
	TakeProfitPrice *string `json:"take_profit_price,omitempty"`

	// TakeProfitSteps If using TP steps, the details of each step.
	TakeProfitSteps *[]struct {
		// AmountPercentage % of base order volume for this TP step.
		AmountPercentage *float32 `json:"amount_percentage,omitempty"`

		// Editable Whether this step can still be edited.
		Editable *bool `json:"editable,omitempty"`

		// ExecutionTimestamp When this TP step executed, or `null`.
		ExecutionTimestamp nullable.Nullable[time.Time] `json:"execution_timestamp,omitempty"`

		// Id Step index.
		Id *int `json:"id,omitempty"`

		// InitialAmount Volume allocated for this TP step.
		InitialAmount *string `json:"initial_amount,omitempty"`

		// PanicSellable Whether this TP step can be closed at market.
		PanicSellable *bool `json:"panic_sellable,omitempty"`

		// Price Trigger price for this TP step.
		Price *string `json:"price,omitempty"`

		// ProfitPercentage % profit target for this TP step.
		ProfitPercentage *float32 `json:"profit_percentage,omitempty"`

		// Status Current status of this TP step.
		Status *string `json:"status,omitempty"`

		// TradeId 3Commas Trade entity ID.
		TradeId *int `json:"trade_id,omitempty"`
	} `json:"take_profit_steps,omitempty"`

	// TakeProfitType Basis for TP calculation (`base` or `total`).
	TakeProfitType *string `json:"take_profit_type,omitempty"`

	// ToCurrency Base currency code.
	ToCurrency   *string `json:"to_currency,omitempty"`
	ToCurrencyId *int    `json:"to_currency_id,omitempty"`

	// TrailingEnabled Trailing Take Profit enabled.
	TrailingEnabled *bool `json:"trailing_enabled,omitempty"`

	// TslEnabled Trailing Stop Loss enabled.
	TslEnabled *bool `json:"tsl_enabled,omitempty"`

	// Type The type of entity.
	Type *string `json:"type,omitempty"`

	// UpdatedAt When the Deal was last updated (ISO 8601).
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UsdFinalProfit Net P/L expressed in USD.
	UsdFinalProfit *string `json:"usd_final_profit,omitempty"`
}

// DealDataForAddingFundsResponse defines model for DealDataForAddingFundsResponse.
type DealDataForAddingFundsResponse struct {
	// AccountId ID of the exchange account entity where this DCA Bot's deal was created.
	AccountId *int `json:"account_id,omitempty"`

	// AccountType Specifies the type of account.
	AccountType *string `json:"account_type,omitempty"`

	// AddingFundsCurrency Currency for additional funds.
	AddingFundsCurrency *string `json:"adding_funds_currency,omitempty"`

	// AvailableAmount The amount of quote currency available for trading.
	AvailableAmount *string `json:"available_amount,omitempty"`

	// BaseCurrency The base currency in the trading pair.
	BaseCurrency *string `json:"base_currency,omitempty"`

	// DealType Indicates the type of deal being executed: long or short.
	DealType *string `json:"deal_type,omitempty"`

	// IsContract Specifies if the trading instrument is a contract.
	IsContract *bool `json:"is_contract,omitempty"`

	// LeverageCustomValue The custom leverage value, if specified.
	LeverageCustomValue nullable.Nullable[string] `json:"leverage_custom_value,omitempty"`

	// LeverageType Type of leverage applied for this Deal.
	LeverageType *string `json:"leverage_type,omitempty"`

	// Limit The limit price for buy or sell orders.
	Limit  *string                `json:"limit,omitempty"`
	Limits *ExchangeTradingLimits `json:"limits,omitempty"`

	// MarketBuyMinTotal The minimum total amount for market buy orders.
	MarketBuyMinTotal *string `json:"market_buy_min_total,omitempty"`

	// MarketSupported Indicates if market orders are supported for this pair.
	MarketSupported *bool `json:"market_supported,omitempty"`

	// MinLotSize The minimum amount of the base currency that can be traded per order.
	MinLotSize *string `json:"min_lot_size,omitempty"`

	// OrderbookPrice The current price from the exchange's order book for the pair.
	OrderbookPrice *string `json:"orderbook_price,omitempty"`

	// OrderbookPriceCurrency Currency used for the order book price.
	OrderbookPriceCurrency *string `json:"orderbook_price_currency,omitempty"`

	// Pair Trading pair in 3Commas format.
	Pair *string `json:"pair,omitempty"`

	// PricePerOneUnitStrategyName The name of the strategy used to determine the price per unit.
	PricePerOneUnitStrategyName *string `json:"price_per_one_unit_strategy_name,omitempty"`

	// QuoteCurrency The quote currency in the trading pair.
	QuoteCurrency *string `json:"quote_currency,omitempty"`

	// StopLossPrice The price set to trigger a stop loss for the bot's deals.
	StopLossPrice nullable.Nullable[string] `json:"stop_loss_price,omitempty"`

	// TakeProfitPrice The set price at which to take profit for the bot's deals.
	TakeProfitPrice *string `json:"take_profit_price,omitempty"`
}

// DealUpdateRequest Parameters for editing an existing DCA Bot deal.
type DealUpdateRequest struct {
	// ActiveSafetyOrdersCount Number of Safety Orders placed in advance on the exchange order book.
	ActiveSafetyOrdersCount *int `json:"active_safety_orders_count,omitempty"`

	// CloseTimeout Seconds after which the deal will auto-close.
	CloseTimeout *int `json:"close_timeout,omitempty"`

	// MaxSafetyOrders Maximum total number of Safety Orders for this deal.
	MaxSafetyOrders *int `json:"max_safety_orders,omitempty"`

	// MinProfitPercentage Minimum profit percentage required to complete the deal.
	MinProfitPercentage *float32 `json:"min_profit_percentage,omitempty"`

	// Note Optional user-defined note for this deal.
	Note *string `json:"note,omitempty"`

	// ProfitCurrency Currency used to calculate profit (`quote_currency` or `base_currency`).
	ProfitCurrency *DealUpdateRequestProfitCurrency `json:"profit_currency,omitempty"`

	// SlToBreakevenData Upper limit to which stop loss will move when breakeven is activated.
	SlToBreakevenData *struct {
		UpperBreakevenLimit *float32 `json:"upper_breakeven_limit,omitempty"`
	} `json:"sl_to_breakeven_data,omitempty"`

	// SlToBreakevenEnabled Enable Move to Breakeven (requires at least two TP steps).
	SlToBreakevenEnabled *bool `json:"sl_to_breakeven_enabled,omitempty"`

	// StopLossPercentage Percentage drop from TP target to trigger a Stop Loss market order.
	StopLossPercentage *float32 `json:"stop_loss_percentage,omitempty"`

	// StopLossTimeoutEnabled Enable timeout before Stop Loss executes.
	StopLossTimeoutEnabled *bool `json:"stop_loss_timeout_enabled,omitempty"`

	// StopLossTimeoutInSeconds Timeout value in seconds; required if stop_loss_timeout_enabled is true.
	StopLossTimeoutInSeconds *int `json:"stop_loss_timeout_in_seconds,omitempty"`

	// StopLossType Action after Stop Loss triggers.
	StopLossType *DealUpdateRequestStopLossType `json:"stop_loss_type,omitempty"`

	// TakeProfit Percentage value for the bot’s Take Profit. Must be 0 if using multiple take_profit_steps.
	TakeProfit *float32 `json:"take_profit,omitempty"`

	// TakeProfitSteps Multiple steps with conditions for Taking Profit in this deal.
	TakeProfitSteps *[]TakeProfitStep `json:"take_profit_steps,omitempty"`

	// TakeProfitType Take Profit order type for this deal.
	TakeProfitType DealUpdateRequestTakeProfitType `json:"take_profit_type"`

	// TrailingEnabled Enable trailing for Take Profit.
	TrailingEnabled *bool `json:"trailing_enabled,omitempty"`

	// TslEnabled Enable trailing for Stop Loss.
	TslEnabled *bool `json:"tsl_enabled,omitempty"`
}

// DealUpdateRequestProfitCurrency Currency used to calculate profit (`quote_currency` or `base_currency`).
type DealUpdateRequestProfitCurrency string

// DealUpdateRequestStopLossType Action after Stop Loss triggers.
type DealUpdateRequestStopLossType string

// DealUpdateRequestTakeProfitType Take Profit order type for this deal.
type DealUpdateRequestTakeProfitType string

// DealsStats defines model for DealsStats.
type DealsStats struct {
	// Active The number of currently active deals.
	Active *int `json:"active,omitempty"`

	// ActiveDealsBtcProfit The current profit or loss from active deals in BTC.
	ActiveDealsBtcProfit *string `json:"active_deals_btc_profit,omitempty"`

	// ActiveDealsUsdProfit The current profit or loss from active deals in USD.
	ActiveDealsUsdProfit *string `json:"active_deals_usd_profit,omitempty"`

	// BtcFundsLockedInActiveDeals The total funds currently locked in active deals, in BTC.
	BtcFundsLockedInActiveDeals *string `json:"btc_funds_locked_in_active_deals,omitempty"`

	// Completed The total number of completed deals.
	Completed *int `json:"completed,omitempty"`

	// CompletedDealsBtcProfit The total profit from completed deals in BTC.
	CompletedDealsBtcProfit *string `json:"completed_deals_btc_profit,omitempty"`

	// CompletedDealsUsdProfit The total profit from completed deals in USD.
	CompletedDealsUsdProfit *string `json:"completed_deals_usd_profit,omitempty"`

	// FromCurrencyIsDollars Shows whether the base currency for profit calculation is USD.
	FromCurrencyIsDollars *bool `json:"from_currency_is_dollars,omitempty"`

	// FundsLockedInActiveDeals The total funds currently locked in active deals, in USD.
	FundsLockedInActiveDeals *string `json:"funds_locked_in_active_deals,omitempty"`

	// PanicSold The number of deals closed at market price.
	PanicSold *int `json:"panic_sold,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Error Short error code
	Error string `json:"error"`

	// ErrorAttributes Validation errors keyed by field name
	ErrorAttributes *map[string][]string `json:"error_attributes,omitempty"`

	// ErrorDescription Human-readable error message
	ErrorDescription *string `json:"error_description,omitempty"`
}

// ExchangeTradingLimits defines model for ExchangeTradingLimits.
type ExchangeTradingLimits struct {
	// LotStep Lot size step increment.
	LotStep *string `json:"lotStep,omitempty"`

	// MarketBuyMinTotal Minimum total amount for market buy orders.
	MarketBuyMinTotal *string `json:"marketBuyMinTotal,omitempty"`

	// MaxLotSize Maximum lot size for orders.
	MaxLotSize *string `json:"maxLotSize,omitempty"`

	// MaxMarketBuyAmount Maximum order size in base currency for market buy.
	MaxMarketBuyAmount *string `json:"maxMarketBuyAmount,omitempty"`

	// MaxMarketSellAmount Maximum order size in base currency for market sell.
	MaxMarketSellAmount *string `json:"maxMarketSellAmount,omitempty"`

	// MaxPrice Maximum price.
	MaxPrice *string `json:"maxPrice,omitempty"`

	// MinLotSize The minimum lot size for order in base currency.
	MinLotSize *string `json:"minLotSize,omitempty"`

	// MinMarketBuyAmount Minimum order size in base currency for market buy.
	MinMarketBuyAmount *string `json:"minMarketBuyAmount,omitempty"`

	// MinMarketSellAmount Minimum order size in base currency for market sell.
	MinMarketSellAmount *string `json:"minMarketSellAmount,omitempty"`

	// MinPrice Minimum price.
	MinPrice *string `json:"minPrice,omitempty"`

	// MinTotal Minimum total order size in quote currency.
	MinTotal *string `json:"minTotal,omitempty"`

	// PriceMultiplierDown Multiplier applied to decrease the price.
	PriceMultiplierDown *string `json:"priceMultiplierDown,omitempty"`

	// PriceMultiplierUp Multiplier applied to increase the price.
	PriceMultiplierUp *string `json:"priceMultiplierUp,omitempty"`

	// PriceStep The minimum step for changing the price.
	PriceStep *string `json:"priceStep,omitempty"`
}

// FormField defines model for FormField.
type FormField struct {
	// Field The parameter needed to connect a new exchange account.
	Field string `json:"field"`

	// LocalizedName Display name of the field, localized for user convenience.
	LocalizedName string `json:"localized_name"`
}

// FormFields defines model for FormFields.
type FormFields struct {
	Optional []FormField `json:"optional"`
	Required []FormField `json:"required"`
}

// LeverageData defines model for LeverageData.
type LeverageData struct {
	// AvailableLeverageValues Available leverage values for settings for this pair and exchange.
	AvailableLeverageValues *[]string `json:"available_leverage_values,omitempty"`

	// CanSetLeverageValue Indicates whether a custom leverage value can be set.
	CanSetLeverageValue *bool `json:"can_set_leverage_value,omitempty"`

	// Code The type of leverage available.
	Code *string `json:"code,omitempty"`

	// MaxLeverage The maximum leverage value allowed for this contract.
	MaxLeverage *string `json:"max_leverage,omitempty"`

	// Name Name of the leverage option available for this contract.
	Name *string `json:"name,omitempty"`

	// Valid Contains minimum and maximum leverage value that can be applied for this pair.
	Valid *struct {
		// Max The maximum leverage value that can be applied to this contract.
		Max string `json:"max"`

		// Min The minimum leverage value that can be applied to this contract.
		Min float32 `json:"min"`
	} `json:"valid,omitempty"`
}

// MarketListItem defines model for MarketListItem.
type MarketListItem struct {
	// AvailableConnectionFlows Available exchange connection types in 3Commas.
	AvailableConnectionFlows []MarketListItemAvailableConnectionFlows `json:"available_connection_flows"`

	// FastConnectActionName Name of the exchange for fast connection option in the 3Commas system.
	FastConnectActionName string     `json:"fast_connect_action_name"`
	FormFields            FormFields `json:"form_fields"`

	// HelpLink Public URL to the help page with detailed instructions on connecting the exchange.
	HelpLink string `json:"help_link"`

	// MarketCode 3Commas exchange code entity.
	MarketCode string `json:"market_code"`

	// MarketIcon URL link to the icon for this exchange.
	MarketIcon string `json:"market_icon"`

	// MarketName Name of the exchange in the 3Commas system.
	MarketName string `json:"market_name"`

	// MarketUrl Referral link to the exchange website.
	MarketUrl string `json:"market_url"`

	// ThirdPartyAllowed Indicates whether this exchange allows connection by third-party apps.
	ThirdPartyAllowed bool `json:"third_party_allowed"`

	// TrustedIps List of IP addresses that need to be whitelisted on the exchange's website for 3Commas to work with the exchange.
	TrustedIps []string `json:"trusted_ips"`

	// TrustedIpsInputType Input type for trusted IP addresses.
	TrustedIpsInputType string `json:"trusted_ips_input_type"`
}

// MarketListItemAvailableConnectionFlows defines model for MarketListItem.AvailableConnectionFlows.
type MarketListItemAvailableConnectionFlows string

// MarketOrder defines model for MarketOrder.
type MarketOrder struct {
	AveragePrice string `json:"average_price"`

	// Cancellable Indicates whether this trade can be canceled.
	Cancellable bool      `json:"cancellable"`
	CreatedAt   time.Time `json:"created_at"`

	// DealOrderType The type of the order to be created by this trade.
	DealOrderType string `json:"deal_order_type"`

	// OrderId Unique 3Commas Trade entity ID.
	OrderId string `json:"order_id"`

	// OrderType The side of the order to be created by this trade.
	OrderType         string `json:"order_type"`
	Quantity          string `json:"quantity"`
	QuantityRemaining string `json:"quantity_remaining"`
	Rate              string `json:"rate"`

	// StatusString 3Commas status for this Trade.
	StatusString string    `json:"status_string"`
	Total        string    `json:"total"`
	UpdatedAt    time.Time `json:"updated_at"`
}

// Pairs Trading pair(s) in 3Commas format.
type Pairs = []string

// PairsResponse Response wrapper for a list of trading pairs
type PairsResponse struct {
	// Pairs Trading pair(s) in 3Commas format.
	Pairs Pairs `json:"pairs"`
}

// ProfitByDay defines model for ProfitByDay.
type ProfitByDay = []struct {
	Profit struct {
		Btc *string `json:"btc,omitempty"`
		Usd *string `json:"usd,omitempty"`
	} `json:"profit"`
	SDate         openapi_types.Date `json:"s_date"`
	UnixTimestamp int                `json:"unix_timestamp"`
}

// StrategyConfig Configuration object for an individual strategy in strategy_list, close_strategy_list, or safety_strategy_list.
type StrategyConfig struct {
	// Options Strategy-specific parameters (keys depend on the chosen strategy; see examples below).
	Options *map[string]interface{} `json:"options,omitempty"`

	// Strategy Identifier of the strategy, e.g.
	// - "manual"
	// - "nonstop"
	// - "trading_view"
	// - "rsi"
	Strategy *string `json:"strategy,omitempty"`
}

// StrategyDefinition defines model for StrategyDefinition.
type StrategyDefinition struct {
	// AccountsWhitelist List of account types supported by this strategy.
	AccountsWhitelist nullable.Nullable[[]string] `json:"accounts_whitelist,omitempty"`

	// Beta Indicates if the strategy is in beta.
	Beta bool `json:"beta"`

	// Name Human-readable name of the strategy.
	Name string `json:"name"`

	// Options Strategy-specific parameters.
	Options nullable.Nullable[map[string]interface{}] `json:"options,omitempty"`

	// Payed Indicates if the strategy requires payment.
	Payed bool `json:"payed"`

	// StrategyType Type of strategy (e.g., signal, indicator).
	StrategyType string `json:"strategy_type"`
}

// StrategyList defines model for StrategyList.
type StrategyList map[string]StrategyDefinition

// TakeProfitStep defines model for TakeProfitStep.
type TakeProfitStep struct {
	// AmountPercentage The percentage of the base order volume to be allocated for this Take Profit step.
	AmountPercentage *int `json:"amount_percentage,omitempty"`

	// Id Step number of Take Profit.
	Id *int `json:"id,omitempty"`

	// ProfitPercentage The specific profit percentage applied to the volume of units for this Take Profit step.
	ProfitPercentage *int `json:"profit_percentage,omitempty"`
}

// UpdateBotRequest defines model for UpdateBotRequest.
type UpdateBotRequest = BotEntity

// ValidateResponse defines model for ValidateResponse.
type ValidateResponse struct {
	// Valid Indicates whether the provided API credentials are valid.
	Valid bool `json:"valid"`
}

// AccountQueryId defines model for AccountQueryId.
type AccountQueryId = int

// BotPathId defines model for BotPathId.
type BotPathId = int

// DealPathId defines model for DealPathId.
type DealPathId = int

// TradeQueryId defines model for TradeQueryId.
type TradeQueryId = int

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// BotCreated defines model for BotCreated.
type BotCreated = Bot

// BotOK defines model for BotOK.
type BotOK = Bot

// BotUpdated defines model for BotUpdated.
type BotUpdated = Bot

// DealResponse A single DCA‐bot deal, with all its execution and P/L details.
type DealResponse = Deal

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ErrorResponse

// IPAutoBanned defines model for IPAutoBanned.
type IPAutoBanned = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// RateLimitExceeded defines model for RateLimitExceeded.
type RateLimitExceeded = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// GetCurrencyRatesParams defines parameters for GetCurrencyRates.
type GetCurrencyRatesParams struct {
	// MarketCode Unique exchange code in the 3Commas system. Use endpoint Supported markets list to get value for parameter market_code.
	MarketCode int `form:"market_code" json:"market_code"`

	// Pair Trading pair in 3Commas format. Use endpoints All Market Pairs to get value for parameter pair in 3Commas format.
	Pair string `form:"pair" json:"pair"`

	// LimitType Defines the type of trading limits returned based on the selected trading tool bot or smart_trade. If set to bot, the response includes trading limits specific to DCA, Signal and Grid Bots. If set to smart_trade, the response includes trading limits for SmartTrade.
	LimitType *GetCurrencyRatesParamsLimitType `form:"limit_type,omitempty" json:"limit_type,omitempty"`
}

// GetCurrencyRatesParamsLimitType defines parameters for GetCurrencyRates.
type GetCurrencyRatesParamsLimitType string

// GetCurrencyRatesWithLeverageDataParams defines parameters for GetCurrencyRatesWithLeverageData.
type GetCurrencyRatesWithLeverageDataParams struct {
	// MarketCode Unique exchange code in the 3Commas system. Use endpoint Supported markets list to get value for parameter market_code.
	MarketCode int `form:"market_code" json:"market_code"`

	// Pair Trading pair in 3Commas format. Use endpoints All Market Pairs to get value for parameter pair in 3Commas format.
	Pair string `form:"pair" json:"pair"`
}

// GetMarketPairsParams defines parameters for GetMarketPairs.
type GetMarketPairsParams struct {
	// MarketCode Unique exchange code in the 3Commas system. Use the “Supported markets list” endpoint to get valid values.
	MarketCode string `form:"market_code" json:"market_code"`
}

// ListBotsParams defines parameters for ListBots.
type ListBotsParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// Strategy Filters bots by trading strategy type.
	Strategy *ListBotsParamsStrategy `form:"strategy,omitempty" json:"strategy,omitempty"`

	// OrderDirection Sets the direction of ordering.
	OrderDirection *ListBotsParamsOrderDirection `form:"order_direction,omitempty" json:"order_direction,omitempty"`

	// Limit Limits the number of records returned (max 100).
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Skips the first N records in the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// From Returns entities created after a specific timestamp (ms since epoch).
	From *int `form:"from,omitempty" json:"from,omitempty"`

	// Scope Filters bots by their status.
	Scope *ListBotsParamsScope `form:"scope,omitempty" json:"scope,omitempty"`

	// SortBy Specifies the field used to order the results.
	SortBy *ListBotsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Quote Filters by quote currency.
	Quote *string `form:"quote,omitempty" json:"quote,omitempty"`
}

// ListBotsParamsStrategy defines parameters for ListBots.
type ListBotsParamsStrategy string

// ListBotsParamsOrderDirection defines parameters for ListBots.
type ListBotsParamsOrderDirection string

// ListBotsParamsScope defines parameters for ListBots.
type ListBotsParamsScope string

// ListBotsParamsSortBy defines parameters for ListBots.
type ListBotsParamsSortBy string

// GetBotsStatsParams defines parameters for GetBotsStats.
type GetBotsStatsParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// BotId Filters entities linked to the specified DCA Bot.
	BotId *int `form:"bot_id,omitempty" json:"bot_id,omitempty"`
}

// GetBotsStatsByDateParams defines parameters for GetBotsStatsByDate.
type GetBotsStatsByDateParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// BotId Filters entities linked to the specified DCA Bot.
	BotId *int `form:"bot_id,omitempty" json:"bot_id,omitempty"`

	// Date Specific day for which profit data is requested for this bot or account.
	Date time.Time `form:"date" json:"date"`
}

// ListStrategiesParams defines parameters for ListStrategies.
type ListStrategiesParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// Type Specifies the strategy direction for the bot.
	Type *ListStrategiesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Strategy Specifies the type of strategy list.
	Strategy *ListStrategiesParamsStrategy `form:"strategy,omitempty" json:"strategy,omitempty"`
}

// ListStrategiesParamsType defines parameters for ListStrategies.
type ListStrategiesParamsType string

// ListStrategiesParamsStrategy defines parameters for ListStrategies.
type ListStrategiesParamsStrategy string

// UpdatePairsBlacklistParams defines parameters for UpdatePairsBlacklist.
type UpdatePairsBlacklistParams struct {
	// Pairs Trading pair(s) in 3Commas format. Use the endpoint All Market Pairs to get valid values.
	Pairs string `form:"pairs" json:"pairs"`
}

// GetProfitByDayParams defines parameters for GetProfitByDay.
type GetProfitByDayParams struct {
	// Days Specifies the number of days for which profit data is requested for this bot.
	Days *int `form:"days,omitempty" json:"days,omitempty"`
}

// GetBotParams defines parameters for GetBot.
type GetBotParams struct {
	// IncludeEvents Indicates whether to include information about events related to the entity.
	IncludeEvents bool `form:"include_events" json:"include_events"`
}

// ListDealsParams defines parameters for ListDeals.
type ListDealsParams struct {
	// BotId Filters by the unique ID of the 3Commas DCA Bot.
	BotId *int `form:"bot_id,omitempty" json:"bot_id,omitempty"`

	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// Limit Limits the number of records returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Skips the first N records in the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// From Returns entities created after a specific time.
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// To Returns entities created before a specific time.
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// Scope Filters deals by their status.
	Scope *ListDealsParamsScope `form:"scope,omitempty" json:"scope,omitempty"`

	// Order Specifies the field used to order the results.
	Order *ListDealsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderDirection Sets the direction of order: ASC or DESC.
	OrderDirection *ListDealsParamsOrderDirection `form:"order_direction,omitempty" json:"order_direction,omitempty"`

	// Base Filters by base currency.
	Base *string `form:"base,omitempty" json:"base,omitempty"`

	// Quote Filters by quote currency.
	Quote *string `form:"quote,omitempty" json:"quote,omitempty"`

	// Note Filters deals by note.
	Note *string `form:"note,omitempty" json:"note,omitempty"`
}

// ListDealsParamsScope defines parameters for ListDeals.
type ListDealsParamsScope string

// ListDealsParamsOrder defines parameters for ListDeals.
type ListDealsParamsOrder string

// ListDealsParamsOrderDirection defines parameters for ListDeals.
type ListDealsParamsOrderDirection string

// PanicSellDealStepParams defines parameters for PanicSellDealStep.
type PanicSellDealStepParams struct {
	// TradeId Unique 3Commas ID for the Trade entity within the deal that should be sold. Use the Get Deal endpoint to retrieve trade_id values.
	TradeId TradeQueryId `form:"trade_id" json:"trade_id"`
}

// CreateDcaBotJSONRequestBody defines body for CreateDcaBot for application/json ContentType.
type CreateDcaBotJSONRequestBody = CreateBotRequest

// CopyAndCreateBotJSONRequestBody defines body for CopyAndCreateBot for application/json ContentType.
type CopyAndCreateBotJSONRequestBody = CopyBotRequest

// UpdateBotJSONRequestBody defines body for UpdateBot for application/json ContentType.
type UpdateBotJSONRequestBody = UpdateBotRequest

// UpdateDealJSONRequestBody defines body for UpdateDeal for application/json ContentType.
type UpdateDealJSONRequestBody = DealUpdateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCurrencyRates request
	GetCurrencyRates(ctx context.Context, params *GetCurrencyRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrencyRatesWithLeverageData request
	GetCurrencyRatesWithLeverageData(ctx context.Context, params *GetCurrencyRatesWithLeverageDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketList request
	GetMarketList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketPairs request
	GetMarketPairs(ctx context.Context, params *GetMarketPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBots request
	ListBots(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDcaBotWithBody request with any body
	CreateDcaBotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDcaBot(ctx context.Context, body CreateDcaBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPairsBlacklist request
	GetPairsBlacklist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBotsStats request
	GetBotsStats(ctx context.Context, params *GetBotsStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBotsStatsByDate request
	GetBotsStatsByDate(ctx context.Context, params *GetBotsStatsByDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStrategies request
	ListStrategies(ctx context.Context, params *ListStrategiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePairsBlacklist request
	UpdatePairsBlacklist(ctx context.Context, params *UpdatePairsBlacklistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelAllDeals request
	CancelAllDeals(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyAndCreateBotWithBody request with any body
	CopyAndCreateBotWithBody(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyAndCreateBot(ctx context.Context, botId BotPathId, body CopyAndCreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealsStats request
	GetDealsStats(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBot request
	DeleteBot(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableBot request
	DisableBot(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableBot request
	EnableBot(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PanicSellAllDeals request
	PanicSellAllDeals(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfitByDay request
	GetProfitByDay(ctx context.Context, botId BotPathId, params *GetProfitByDayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBot request
	GetBot(ctx context.Context, botId BotPathId, params *GetBotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBotWithBody request with any body
	UpdateBotWithBody(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBot(ctx context.Context, botId BotPathId, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeals request
	ListDeals(ctx context.Context, params *ListDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelDeal request
	CancelDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealDataForAddingFunds request
	GetDealDataForAddingFunds(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTradesOfDeal request
	GetTradesOfDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PanicSellDeal request
	PanicSellDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PanicSellDealStep request
	PanicSellDealStep(ctx context.Context, dealId DealPathId, params *PanicSellDealStepParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeal request
	GetDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDealWithBody request with any body
	UpdateDealWithBody(ctx context.Context, dealId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeal(ctx context.Context, dealId int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateAuthentication request
	ValidateAuthentication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCurrencyRates(ctx context.Context, params *GetCurrencyRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrencyRatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrencyRatesWithLeverageData(ctx context.Context, params *GetCurrencyRatesWithLeverageDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrencyRatesWithLeverageDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketPairs(ctx context.Context, params *GetMarketPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketPairsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBots(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDcaBotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDcaBotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDcaBot(ctx context.Context, body CreateDcaBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDcaBotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPairsBlacklist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPairsBlacklistRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBotsStats(ctx context.Context, params *GetBotsStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotsStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBotsStatsByDate(ctx context.Context, params *GetBotsStatsByDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotsStatsByDateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStrategies(ctx context.Context, params *ListStrategiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStrategiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePairsBlacklist(ctx context.Context, params *UpdatePairsBlacklistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePairsBlacklistRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelAllDeals(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelAllDealsRequest(c.Server, botId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyAndCreateBotWithBody(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyAndCreateBotRequestWithBody(c.Server, botId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyAndCreateBot(ctx context.Context, botId BotPathId, body CopyAndCreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyAndCreateBotRequest(c.Server, botId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealsStats(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealsStatsRequest(c.Server, botId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBot(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBotRequest(c.Server, botId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableBot(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableBotRequest(c.Server, botId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableBot(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableBotRequest(c.Server, botId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PanicSellAllDeals(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPanicSellAllDealsRequest(c.Server, botId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfitByDay(ctx context.Context, botId BotPathId, params *GetProfitByDayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfitByDayRequest(c.Server, botId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBot(ctx context.Context, botId BotPathId, params *GetBotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotRequest(c.Server, botId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBotWithBody(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBotRequestWithBody(c.Server, botId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBot(ctx context.Context, botId BotPathId, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBotRequest(c.Server, botId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeals(ctx context.Context, params *ListDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDealsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelDealRequest(c.Server, dealId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealDataForAddingFunds(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealDataForAddingFundsRequest(c.Server, dealId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTradesOfDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTradesOfDealRequest(c.Server, dealId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PanicSellDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPanicSellDealRequest(c.Server, dealId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PanicSellDealStep(ctx context.Context, dealId DealPathId, params *PanicSellDealStepParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPanicSellDealStepRequest(c.Server, dealId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeal(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealRequest(c.Server, dealId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealWithBody(ctx context.Context, dealId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealRequestWithBody(c.Server, dealId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeal(ctx context.Context, dealId int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealRequest(c.Server, dealId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateAuthentication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateAuthenticationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCurrencyRatesRequest generates requests for GetCurrencyRates
func NewGetCurrencyRatesRequest(server string, params *GetCurrencyRatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/accounts/currency_rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_code", runtime.ParamLocationQuery, params.MarketCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pair", runtime.ParamLocationQuery, params.Pair); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LimitType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_type", runtime.ParamLocationQuery, *params.LimitType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrencyRatesWithLeverageDataRequest generates requests for GetCurrencyRatesWithLeverageData
func NewGetCurrencyRatesWithLeverageDataRequest(server string, params *GetCurrencyRatesWithLeverageDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/accounts/currency_rates_with_leverage_data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_code", runtime.ParamLocationQuery, params.MarketCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pair", runtime.ParamLocationQuery, params.Pair); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketListRequest generates requests for GetMarketList
func NewGetMarketListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/accounts/market_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketPairsRequest generates requests for GetMarketPairs
func NewGetMarketPairsRequest(server string, params *GetMarketPairsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/accounts/market_pairs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_code", runtime.ParamLocationQuery, params.MarketCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBotsRequest generates requests for ListBots
func NewListBotsRequest(server string, params *ListBotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_id", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Strategy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strategy", runtime.ParamLocationQuery, *params.Strategy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_direction", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quote != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDcaBotRequest calls the generic CreateDcaBot builder with application/json body
func NewCreateDcaBotRequest(server string, body CreateDcaBotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDcaBotRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDcaBotRequestWithBody generates requests for CreateDcaBot with any type of body
func NewCreateDcaBotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/create_bot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPairsBlacklistRequest generates requests for GetPairsBlacklist
func NewGetPairsBlacklistRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/pairs_black_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBotsStatsRequest generates requests for GetBotsStats
func NewGetBotsStatsRequest(server string, params *GetBotsStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_id", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BotId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bot_id", runtime.ParamLocationQuery, *params.BotId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBotsStatsByDateRequest generates requests for GetBotsStatsByDate
func NewGetBotsStatsByDateRequest(server string, params *GetBotsStatsByDateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/stats_by_date")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_id", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BotId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bot_id", runtime.ParamLocationQuery, *params.BotId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStrategiesRequest generates requests for ListStrategies
func NewListStrategiesRequest(server string, params *ListStrategiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/strategy_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_id", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Strategy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strategy", runtime.ParamLocationQuery, *params.Strategy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePairsBlacklistRequest generates requests for UpdatePairsBlacklist
func NewUpdatePairsBlacklistRequest(server string, params *UpdatePairsBlacklistParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/update_pairs_black_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pairs", runtime.ParamLocationQuery, params.Pairs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelAllDealsRequest generates requests for CancelAllDeals
func NewCancelAllDealsRequest(server string, botId BotPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/cancel_all_deals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCopyAndCreateBotRequest calls the generic CopyAndCreateBot builder with application/json body
func NewCopyAndCreateBotRequest(server string, botId BotPathId, body CopyAndCreateBotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyAndCreateBotRequestWithBody(server, botId, "application/json", bodyReader)
}

// NewCopyAndCreateBotRequestWithBody generates requests for CopyAndCreateBot with any type of body
func NewCopyAndCreateBotRequestWithBody(server string, botId BotPathId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/copy_and_create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDealsStatsRequest generates requests for GetDealsStats
func NewGetDealsStatsRequest(server string, botId BotPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/deals_stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBotRequest generates requests for DeleteBot
func NewDeleteBotRequest(server string, botId BotPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableBotRequest generates requests for DisableBot
func NewDisableBotRequest(server string, botId BotPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableBotRequest generates requests for EnableBot
func NewEnableBotRequest(server string, botId BotPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPanicSellAllDealsRequest generates requests for PanicSellAllDeals
func NewPanicSellAllDealsRequest(server string, botId BotPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/panic_sell_all_deals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfitByDayRequest generates requests for GetProfitByDay
func NewGetProfitByDayRequest(server string, botId BotPathId, params *GetProfitByDayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/profit_by_day", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBotRequest generates requests for GetBot
func NewGetBotRequest(server string, botId BotPathId, params *GetBotParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/show", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_events", runtime.ParamLocationQuery, params.IncludeEvents); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBotRequest calls the generic UpdateBot builder with application/json body
func NewUpdateBotRequest(server string, botId BotPathId, body UpdateBotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBotRequestWithBody(server, botId, "application/json", bodyReader)
}

// NewUpdateBotRequestWithBody generates requests for UpdateBot with any type of body
func NewUpdateBotRequestWithBody(server string, botId BotPathId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_id", runtime.ParamLocationPath, botId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/bots/%s/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDealsRequest generates requests for ListDeals
func NewListDealsRequest(server string, params *ListDealsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BotId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bot_id", runtime.ParamLocationQuery, *params.BotId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_id", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_direction", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Base != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quote != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quote", runtime.ParamLocationQuery, *params.Quote); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Note != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "note", runtime.ParamLocationQuery, *params.Note); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelDealRequest generates requests for CancelDeal
func NewCancelDealRequest(server string, dealId DealPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deal_id", runtime.ParamLocationPath, dealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealDataForAddingFundsRequest generates requests for GetDealDataForAddingFunds
func NewGetDealDataForAddingFundsRequest(server string, dealId DealPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deal_id", runtime.ParamLocationPath, dealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals/%s/data_for_adding_funds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTradesOfDealRequest generates requests for GetTradesOfDeal
func NewGetTradesOfDealRequest(server string, dealId DealPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deal_id", runtime.ParamLocationPath, dealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals/%s/market_orders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPanicSellDealRequest generates requests for PanicSellDeal
func NewPanicSellDealRequest(server string, dealId DealPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deal_id", runtime.ParamLocationPath, dealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals/%s/panic_sell", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPanicSellDealStepRequest generates requests for PanicSellDealStep
func NewPanicSellDealStepRequest(server string, dealId DealPathId, params *PanicSellDealStepParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deal_id", runtime.ParamLocationPath, dealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals/%s/panic_sell_step", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trade_id", runtime.ParamLocationQuery, params.TradeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealRequest generates requests for GetDeal
func NewGetDealRequest(server string, dealId DealPathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deal_id", runtime.ParamLocationPath, dealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals/%s/show", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDealRequest calls the generic UpdateDeal builder with application/json body
func NewUpdateDealRequest(server string, dealId int, body UpdateDealJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDealRequestWithBody(server, dealId, "application/json", bodyReader)
}

// NewUpdateDealRequestWithBody generates requests for UpdateDeal with any type of body
func NewUpdateDealRequestWithBody(server string, dealId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deal_id", runtime.ParamLocationPath, dealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/deals/%s/update_deal", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateAuthenticationRequest generates requests for ValidateAuthentication
func NewValidateAuthenticationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ver1/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCurrencyRatesWithResponse request
	GetCurrencyRatesWithResponse(ctx context.Context, params *GetCurrencyRatesParams, reqEditors ...RequestEditorFn) (*GetCurrencyRatesResponse, error)

	// GetCurrencyRatesWithLeverageDataWithResponse request
	GetCurrencyRatesWithLeverageDataWithResponse(ctx context.Context, params *GetCurrencyRatesWithLeverageDataParams, reqEditors ...RequestEditorFn) (*GetCurrencyRatesWithLeverageDataResponse, error)

	// GetMarketListWithResponse request
	GetMarketListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketListResponse, error)

	// GetMarketPairsWithResponse request
	GetMarketPairsWithResponse(ctx context.Context, params *GetMarketPairsParams, reqEditors ...RequestEditorFn) (*GetMarketPairsResponse, error)

	// ListBotsWithResponse request
	ListBotsWithResponse(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*ListBotsResponse, error)

	// CreateDcaBotWithBodyWithResponse request with any body
	CreateDcaBotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDcaBotResponse, error)

	CreateDcaBotWithResponse(ctx context.Context, body CreateDcaBotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDcaBotResponse, error)

	// GetPairsBlacklistWithResponse request
	GetPairsBlacklistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPairsBlacklistResponse, error)

	// GetBotsStatsWithResponse request
	GetBotsStatsWithResponse(ctx context.Context, params *GetBotsStatsParams, reqEditors ...RequestEditorFn) (*GetBotsStatsResponse, error)

	// GetBotsStatsByDateWithResponse request
	GetBotsStatsByDateWithResponse(ctx context.Context, params *GetBotsStatsByDateParams, reqEditors ...RequestEditorFn) (*GetBotsStatsByDateResponse, error)

	// ListStrategiesWithResponse request
	ListStrategiesWithResponse(ctx context.Context, params *ListStrategiesParams, reqEditors ...RequestEditorFn) (*ListStrategiesResponse, error)

	// UpdatePairsBlacklistWithResponse request
	UpdatePairsBlacklistWithResponse(ctx context.Context, params *UpdatePairsBlacklistParams, reqEditors ...RequestEditorFn) (*UpdatePairsBlacklistResponse, error)

	// CancelAllDealsWithResponse request
	CancelAllDealsWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*CancelAllDealsResponse, error)

	// CopyAndCreateBotWithBodyWithResponse request with any body
	CopyAndCreateBotWithBodyWithResponse(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyAndCreateBotResponse, error)

	CopyAndCreateBotWithResponse(ctx context.Context, botId BotPathId, body CopyAndCreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyAndCreateBotResponse, error)

	// GetDealsStatsWithResponse request
	GetDealsStatsWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*GetDealsStatsResponse, error)

	// DeleteBotWithResponse request
	DeleteBotWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*DeleteBotResponse, error)

	// DisableBotWithResponse request
	DisableBotWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*DisableBotResponse, error)

	// EnableBotWithResponse request
	EnableBotWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*EnableBotResponse, error)

	// PanicSellAllDealsWithResponse request
	PanicSellAllDealsWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*PanicSellAllDealsResponse, error)

	// GetProfitByDayWithResponse request
	GetProfitByDayWithResponse(ctx context.Context, botId BotPathId, params *GetProfitByDayParams, reqEditors ...RequestEditorFn) (*GetProfitByDayResponse, error)

	// GetBotWithResponse request
	GetBotWithResponse(ctx context.Context, botId BotPathId, params *GetBotParams, reqEditors ...RequestEditorFn) (*GetBotResponse, error)

	// UpdateBotWithBodyWithResponse request with any body
	UpdateBotWithBodyWithResponse(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBotResponse, error)

	UpdateBotWithResponse(ctx context.Context, botId BotPathId, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBotResponse, error)

	// ListDealsWithResponse request
	ListDealsWithResponse(ctx context.Context, params *ListDealsParams, reqEditors ...RequestEditorFn) (*ListDealsResponse, error)

	// CancelDealWithResponse request
	CancelDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*CancelDealResponse, error)

	// GetDealDataForAddingFundsWithResponse request
	GetDealDataForAddingFundsWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*GetDealDataForAddingFundsResponse, error)

	// GetTradesOfDealWithResponse request
	GetTradesOfDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*GetTradesOfDealResponse, error)

	// PanicSellDealWithResponse request
	PanicSellDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*PanicSellDealResponse, error)

	// PanicSellDealStepWithResponse request
	PanicSellDealStepWithResponse(ctx context.Context, dealId DealPathId, params *PanicSellDealStepParams, reqEditors ...RequestEditorFn) (*PanicSellDealStepResponse, error)

	// GetDealWithResponse request
	GetDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*GetDealResponse, error)

	// UpdateDealWithBodyWithResponse request with any body
	UpdateDealWithBodyWithResponse(ctx context.Context, dealId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error)

	UpdateDealWithResponse(ctx context.Context, dealId int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error)

	// ValidateAuthenticationWithResponse request
	ValidateAuthenticationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAuthenticationResponse, error)
}

type GetCurrencyRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrencyRates
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetCurrencyRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrencyRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrencyRatesWithLeverageDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrencyRatesWithLeverageData
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetCurrencyRatesWithLeverageDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrencyRatesWithLeverageDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MarketListItem
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetMarketListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketPairsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetMarketPairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketPairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r ListBotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDcaBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r CreateDcaBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDcaBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPairsBlacklistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PairsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetPairsBlacklistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPairsBlacklistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotsStats
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetBotsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotsStatsByDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotsStatsByDate
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetBotsStatsByDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotsStatsByDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStrategiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StrategyList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r ListStrategiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStrategiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePairsBlacklistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PairsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r UpdatePairsBlacklistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePairsBlacklistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelAllDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r CancelAllDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelAllDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyAndCreateBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CopyBotResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r CopyAndCreateBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyAndCreateBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DealsStats
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetDealsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r DeleteBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r DisableBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r EnableBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PanicSellAllDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BotCreated
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r PanicSellAllDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PanicSellAllDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfitByDayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProfitByDay
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetProfitByDayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfitByDayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotUpdated
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r UpdateBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Deal
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r ListDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DealResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r CancelDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealDataForAddingFundsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DealDataForAddingFundsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetDealDataForAddingFundsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealDataForAddingFundsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTradesOfDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MarketOrder
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetTradesOfDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTradesOfDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PanicSellDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DealResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r PanicSellDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PanicSellDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PanicSellDealStepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DealResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r PanicSellDealStepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PanicSellDealStepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DealResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deal
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r UpdateDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateAuthenticationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidateResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON418      *IPAutoBanned
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r ValidateAuthenticationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateAuthenticationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCurrencyRatesWithResponse request returning *GetCurrencyRatesResponse
func (c *ClientWithResponses) GetCurrencyRatesWithResponse(ctx context.Context, params *GetCurrencyRatesParams, reqEditors ...RequestEditorFn) (*GetCurrencyRatesResponse, error) {
	rsp, err := c.GetCurrencyRates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrencyRatesResponse(rsp)
}

// GetCurrencyRatesWithLeverageDataWithResponse request returning *GetCurrencyRatesWithLeverageDataResponse
func (c *ClientWithResponses) GetCurrencyRatesWithLeverageDataWithResponse(ctx context.Context, params *GetCurrencyRatesWithLeverageDataParams, reqEditors ...RequestEditorFn) (*GetCurrencyRatesWithLeverageDataResponse, error) {
	rsp, err := c.GetCurrencyRatesWithLeverageData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrencyRatesWithLeverageDataResponse(rsp)
}

// GetMarketListWithResponse request returning *GetMarketListResponse
func (c *ClientWithResponses) GetMarketListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketListResponse, error) {
	rsp, err := c.GetMarketList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketListResponse(rsp)
}

// GetMarketPairsWithResponse request returning *GetMarketPairsResponse
func (c *ClientWithResponses) GetMarketPairsWithResponse(ctx context.Context, params *GetMarketPairsParams, reqEditors ...RequestEditorFn) (*GetMarketPairsResponse, error) {
	rsp, err := c.GetMarketPairs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketPairsResponse(rsp)
}

// ListBotsWithResponse request returning *ListBotsResponse
func (c *ClientWithResponses) ListBotsWithResponse(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*ListBotsResponse, error) {
	rsp, err := c.ListBots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBotsResponse(rsp)
}

// CreateDcaBotWithBodyWithResponse request with arbitrary body returning *CreateDcaBotResponse
func (c *ClientWithResponses) CreateDcaBotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDcaBotResponse, error) {
	rsp, err := c.CreateDcaBotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDcaBotResponse(rsp)
}

func (c *ClientWithResponses) CreateDcaBotWithResponse(ctx context.Context, body CreateDcaBotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDcaBotResponse, error) {
	rsp, err := c.CreateDcaBot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDcaBotResponse(rsp)
}

// GetPairsBlacklistWithResponse request returning *GetPairsBlacklistResponse
func (c *ClientWithResponses) GetPairsBlacklistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPairsBlacklistResponse, error) {
	rsp, err := c.GetPairsBlacklist(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPairsBlacklistResponse(rsp)
}

// GetBotsStatsWithResponse request returning *GetBotsStatsResponse
func (c *ClientWithResponses) GetBotsStatsWithResponse(ctx context.Context, params *GetBotsStatsParams, reqEditors ...RequestEditorFn) (*GetBotsStatsResponse, error) {
	rsp, err := c.GetBotsStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotsStatsResponse(rsp)
}

// GetBotsStatsByDateWithResponse request returning *GetBotsStatsByDateResponse
func (c *ClientWithResponses) GetBotsStatsByDateWithResponse(ctx context.Context, params *GetBotsStatsByDateParams, reqEditors ...RequestEditorFn) (*GetBotsStatsByDateResponse, error) {
	rsp, err := c.GetBotsStatsByDate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotsStatsByDateResponse(rsp)
}

// ListStrategiesWithResponse request returning *ListStrategiesResponse
func (c *ClientWithResponses) ListStrategiesWithResponse(ctx context.Context, params *ListStrategiesParams, reqEditors ...RequestEditorFn) (*ListStrategiesResponse, error) {
	rsp, err := c.ListStrategies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStrategiesResponse(rsp)
}

// UpdatePairsBlacklistWithResponse request returning *UpdatePairsBlacklistResponse
func (c *ClientWithResponses) UpdatePairsBlacklistWithResponse(ctx context.Context, params *UpdatePairsBlacklistParams, reqEditors ...RequestEditorFn) (*UpdatePairsBlacklistResponse, error) {
	rsp, err := c.UpdatePairsBlacklist(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePairsBlacklistResponse(rsp)
}

// CancelAllDealsWithResponse request returning *CancelAllDealsResponse
func (c *ClientWithResponses) CancelAllDealsWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*CancelAllDealsResponse, error) {
	rsp, err := c.CancelAllDeals(ctx, botId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelAllDealsResponse(rsp)
}

// CopyAndCreateBotWithBodyWithResponse request with arbitrary body returning *CopyAndCreateBotResponse
func (c *ClientWithResponses) CopyAndCreateBotWithBodyWithResponse(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyAndCreateBotResponse, error) {
	rsp, err := c.CopyAndCreateBotWithBody(ctx, botId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyAndCreateBotResponse(rsp)
}

func (c *ClientWithResponses) CopyAndCreateBotWithResponse(ctx context.Context, botId BotPathId, body CopyAndCreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyAndCreateBotResponse, error) {
	rsp, err := c.CopyAndCreateBot(ctx, botId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyAndCreateBotResponse(rsp)
}

// GetDealsStatsWithResponse request returning *GetDealsStatsResponse
func (c *ClientWithResponses) GetDealsStatsWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*GetDealsStatsResponse, error) {
	rsp, err := c.GetDealsStats(ctx, botId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealsStatsResponse(rsp)
}

// DeleteBotWithResponse request returning *DeleteBotResponse
func (c *ClientWithResponses) DeleteBotWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*DeleteBotResponse, error) {
	rsp, err := c.DeleteBot(ctx, botId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBotResponse(rsp)
}

// DisableBotWithResponse request returning *DisableBotResponse
func (c *ClientWithResponses) DisableBotWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*DisableBotResponse, error) {
	rsp, err := c.DisableBot(ctx, botId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableBotResponse(rsp)
}

// EnableBotWithResponse request returning *EnableBotResponse
func (c *ClientWithResponses) EnableBotWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*EnableBotResponse, error) {
	rsp, err := c.EnableBot(ctx, botId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableBotResponse(rsp)
}

// PanicSellAllDealsWithResponse request returning *PanicSellAllDealsResponse
func (c *ClientWithResponses) PanicSellAllDealsWithResponse(ctx context.Context, botId BotPathId, reqEditors ...RequestEditorFn) (*PanicSellAllDealsResponse, error) {
	rsp, err := c.PanicSellAllDeals(ctx, botId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePanicSellAllDealsResponse(rsp)
}

// GetProfitByDayWithResponse request returning *GetProfitByDayResponse
func (c *ClientWithResponses) GetProfitByDayWithResponse(ctx context.Context, botId BotPathId, params *GetProfitByDayParams, reqEditors ...RequestEditorFn) (*GetProfitByDayResponse, error) {
	rsp, err := c.GetProfitByDay(ctx, botId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfitByDayResponse(rsp)
}

// GetBotWithResponse request returning *GetBotResponse
func (c *ClientWithResponses) GetBotWithResponse(ctx context.Context, botId BotPathId, params *GetBotParams, reqEditors ...RequestEditorFn) (*GetBotResponse, error) {
	rsp, err := c.GetBot(ctx, botId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotResponse(rsp)
}

// UpdateBotWithBodyWithResponse request with arbitrary body returning *UpdateBotResponse
func (c *ClientWithResponses) UpdateBotWithBodyWithResponse(ctx context.Context, botId BotPathId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBotResponse, error) {
	rsp, err := c.UpdateBotWithBody(ctx, botId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBotResponse(rsp)
}

func (c *ClientWithResponses) UpdateBotWithResponse(ctx context.Context, botId BotPathId, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBotResponse, error) {
	rsp, err := c.UpdateBot(ctx, botId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBotResponse(rsp)
}

// ListDealsWithResponse request returning *ListDealsResponse
func (c *ClientWithResponses) ListDealsWithResponse(ctx context.Context, params *ListDealsParams, reqEditors ...RequestEditorFn) (*ListDealsResponse, error) {
	rsp, err := c.ListDeals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDealsResponse(rsp)
}

// CancelDealWithResponse request returning *CancelDealResponse
func (c *ClientWithResponses) CancelDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*CancelDealResponse, error) {
	rsp, err := c.CancelDeal(ctx, dealId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelDealResponse(rsp)
}

// GetDealDataForAddingFundsWithResponse request returning *GetDealDataForAddingFundsResponse
func (c *ClientWithResponses) GetDealDataForAddingFundsWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*GetDealDataForAddingFundsResponse, error) {
	rsp, err := c.GetDealDataForAddingFunds(ctx, dealId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealDataForAddingFundsResponse(rsp)
}

// GetTradesOfDealWithResponse request returning *GetTradesOfDealResponse
func (c *ClientWithResponses) GetTradesOfDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*GetTradesOfDealResponse, error) {
	rsp, err := c.GetTradesOfDeal(ctx, dealId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTradesOfDealResponse(rsp)
}

// PanicSellDealWithResponse request returning *PanicSellDealResponse
func (c *ClientWithResponses) PanicSellDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*PanicSellDealResponse, error) {
	rsp, err := c.PanicSellDeal(ctx, dealId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePanicSellDealResponse(rsp)
}

// PanicSellDealStepWithResponse request returning *PanicSellDealStepResponse
func (c *ClientWithResponses) PanicSellDealStepWithResponse(ctx context.Context, dealId DealPathId, params *PanicSellDealStepParams, reqEditors ...RequestEditorFn) (*PanicSellDealStepResponse, error) {
	rsp, err := c.PanicSellDealStep(ctx, dealId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePanicSellDealStepResponse(rsp)
}

// GetDealWithResponse request returning *GetDealResponse
func (c *ClientWithResponses) GetDealWithResponse(ctx context.Context, dealId DealPathId, reqEditors ...RequestEditorFn) (*GetDealResponse, error) {
	rsp, err := c.GetDeal(ctx, dealId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealResponse(rsp)
}

// UpdateDealWithBodyWithResponse request with arbitrary body returning *UpdateDealResponse
func (c *ClientWithResponses) UpdateDealWithBodyWithResponse(ctx context.Context, dealId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error) {
	rsp, err := c.UpdateDealWithBody(ctx, dealId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealResponse(rsp)
}

func (c *ClientWithResponses) UpdateDealWithResponse(ctx context.Context, dealId int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error) {
	rsp, err := c.UpdateDeal(ctx, dealId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealResponse(rsp)
}

// ValidateAuthenticationWithResponse request returning *ValidateAuthenticationResponse
func (c *ClientWithResponses) ValidateAuthenticationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAuthenticationResponse, error) {
	rsp, err := c.ValidateAuthentication(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateAuthenticationResponse(rsp)
}

// ParseGetCurrencyRatesResponse parses an HTTP response from a GetCurrencyRatesWithResponse call
func ParseGetCurrencyRatesResponse(rsp *http.Response) (*GetCurrencyRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrencyRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencyRates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetCurrencyRatesWithLeverageDataResponse parses an HTTP response from a GetCurrencyRatesWithLeverageDataWithResponse call
func ParseGetCurrencyRatesWithLeverageDataResponse(rsp *http.Response) (*GetCurrencyRatesWithLeverageDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrencyRatesWithLeverageDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencyRatesWithLeverageData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetMarketListResponse parses an HTTP response from a GetMarketListWithResponse call
func ParseGetMarketListResponse(rsp *http.Response) (*GetMarketListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MarketListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetMarketPairsResponse parses an HTTP response from a GetMarketPairsWithResponse call
func ParseGetMarketPairsResponse(rsp *http.Response) (*GetMarketPairsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketPairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseListBotsResponse parses an HTTP response from a ListBotsWithResponse call
func ParseListBotsResponse(rsp *http.Response) (*ListBotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseCreateDcaBotResponse parses an HTTP response from a CreateDcaBotWithResponse call
func ParseCreateDcaBotResponse(rsp *http.Response) (*CreateDcaBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDcaBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetPairsBlacklistResponse parses an HTTP response from a GetPairsBlacklistWithResponse call
func ParseGetPairsBlacklistResponse(rsp *http.Response) (*GetPairsBlacklistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPairsBlacklistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PairsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetBotsStatsResponse parses an HTTP response from a GetBotsStatsWithResponse call
func ParseGetBotsStatsResponse(rsp *http.Response) (*GetBotsStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotsStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetBotsStatsByDateResponse parses an HTTP response from a GetBotsStatsByDateWithResponse call
func ParseGetBotsStatsByDateResponse(rsp *http.Response) (*GetBotsStatsByDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotsStatsByDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotsStatsByDate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseListStrategiesResponse parses an HTTP response from a ListStrategiesWithResponse call
func ParseListStrategiesResponse(rsp *http.Response) (*ListStrategiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStrategiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StrategyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseUpdatePairsBlacklistResponse parses an HTTP response from a UpdatePairsBlacklistWithResponse call
func ParseUpdatePairsBlacklistResponse(rsp *http.Response) (*UpdatePairsBlacklistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePairsBlacklistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PairsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseCancelAllDealsResponse parses an HTTP response from a CancelAllDealsWithResponse call
func ParseCancelAllDealsResponse(rsp *http.Response) (*CancelAllDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelAllDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseCopyAndCreateBotResponse parses an HTTP response from a CopyAndCreateBotWithResponse call
func ParseCopyAndCreateBotResponse(rsp *http.Response) (*CopyAndCreateBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyAndCreateBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CopyBotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetDealsStatsResponse parses an HTTP response from a GetDealsStatsWithResponse call
func ParseGetDealsStatsResponse(rsp *http.Response) (*GetDealsStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DealsStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseDeleteBotResponse parses an HTTP response from a DeleteBotWithResponse call
func ParseDeleteBotResponse(rsp *http.Response) (*DeleteBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseDisableBotResponse parses an HTTP response from a DisableBotWithResponse call
func ParseDisableBotResponse(rsp *http.Response) (*DisableBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseEnableBotResponse parses an HTTP response from a EnableBotWithResponse call
func ParseEnableBotResponse(rsp *http.Response) (*EnableBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParsePanicSellAllDealsResponse parses an HTTP response from a PanicSellAllDealsWithResponse call
func ParsePanicSellAllDealsResponse(rsp *http.Response) (*PanicSellAllDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PanicSellAllDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BotCreated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetProfitByDayResponse parses an HTTP response from a GetProfitByDayWithResponse call
func ParseGetProfitByDayResponse(rsp *http.Response) (*GetProfitByDayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfitByDayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProfitByDay
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetBotResponse parses an HTTP response from a GetBotWithResponse call
func ParseGetBotResponse(rsp *http.Response) (*GetBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseUpdateBotResponse parses an HTTP response from a UpdateBotWithResponse call
func ParseUpdateBotResponse(rsp *http.Response) (*UpdateBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotUpdated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseListDealsResponse parses an HTTP response from a ListDealsWithResponse call
func ParseListDealsResponse(rsp *http.Response) (*ListDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Deal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseCancelDealResponse parses an HTTP response from a CancelDealWithResponse call
func ParseCancelDealResponse(rsp *http.Response) (*CancelDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DealResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetDealDataForAddingFundsResponse parses an HTTP response from a GetDealDataForAddingFundsWithResponse call
func ParseGetDealDataForAddingFundsResponse(rsp *http.Response) (*GetDealDataForAddingFundsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealDataForAddingFundsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DealDataForAddingFundsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetTradesOfDealResponse parses an HTTP response from a GetTradesOfDealWithResponse call
func ParseGetTradesOfDealResponse(rsp *http.Response) (*GetTradesOfDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTradesOfDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MarketOrder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParsePanicSellDealResponse parses an HTTP response from a PanicSellDealWithResponse call
func ParsePanicSellDealResponse(rsp *http.Response) (*PanicSellDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PanicSellDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DealResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParsePanicSellDealStepResponse parses an HTTP response from a PanicSellDealStepWithResponse call
func ParsePanicSellDealStepResponse(rsp *http.Response) (*PanicSellDealStepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PanicSellDealStepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DealResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetDealResponse parses an HTTP response from a GetDealWithResponse call
func ParseGetDealResponse(rsp *http.Response) (*GetDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DealResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseUpdateDealResponse parses an HTTP response from a UpdateDealWithResponse call
func ParseUpdateDealResponse(rsp *http.Response) (*UpdateDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseValidateAuthenticationResponse parses an HTTP response from a ValidateAuthenticationWithResponse call
func ParseValidateAuthenticationResponse(rsp *http.Response) (*ValidateAuthenticationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateAuthenticationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 418:
		var dest IPAutoBanned
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON418 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}
